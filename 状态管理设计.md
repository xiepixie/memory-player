# 状态管理设计（Memory Player）

本文记录当前项目在 **全局状态管理** 与 **数据同步层（Supabase/Mock）** 上的技术设计，主要依据：

- [src/store/appStore.ts](cci:7://file:///d:/memory-player/src/store/appStore.ts:0:0-0:0)
- [src/lib/storage/SupabaseAdapter.ts](cci:7://file:///d:/memory-player/src/lib/storage/SupabaseAdapter.ts:0:0-0:0)
- [src/lib/storage/types.ts](cci:7://file:///d:/memory-player/src/lib/storage/types.ts:0:0-0:0)
- 以及辅助文档 [docs/DEVELOPER_GUIDE_FSRS_FLOW.md](cci:7://file:///d:/memory-player/docs/DEVELOPER_GUIDE_FSRS_FLOW.md:0:0-0:0)

---

## 1. 技术栈与总体思路

- **状态管理库**：Zustand
  - 单一全局 store：`useAppStore`。
  - 通过 `devtools` + `persist` 中间件增强：
    - `devtools`：配合浏览器 DevTools 调试。
    - `persist`：仅持久化少量 UI/路径配置（如 `rootPath`、`recentVaults`、`files`、`theme`）。
- **数据服务抽象**：[DataService](cci:2://file:///d:/memory-player/src/lib/storage/types.ts:36:0-127:1) 接口
  - 由 `MockAdapter`（本地开发/离线）与 [SupabaseAdapter](cci:2://file:///d:/memory-player/src/lib/storage/SupabaseAdapter.ts:7:0-892:1)（云端）实现。
  - 上层 `appStore` 不关心具体实现，只通过统一方法读写元数据与 FSRS 状态。
- **FSRS 调度粒度**：
  - 一条 **Card = 一个 Cloze**。
  - 通过 `(noteId, clozeIndex)` 唯一标识一张卡片。

**核心原则**：
- `useAppStore` 负责 App 级别的 UI/Session 状态与 DataService 调用。
- [DataService](cci:2://file:///d:/memory-player/src/lib/storage/types.ts:36:0-127:1) 负责「笔记 → 卡片 → FSRS 状态 → 历史」的持久化与同步。

---

## 2. AppState 结构总览

[AppState](cci:2://file:///d:/memory-player/src/store/appStore.ts:21:0-93:1) 将状态按领域拆分为多个 slice：

- **ServiceSlice**：当前数据服务、登录/同步信息。
- **VaultSlice**：本地库（Vault）、文件列表、元数据、内容缓存、Note ID 映射。
- **HistorySlice**：复习历史与待同步计数。
- **SessionSlice**：当前复习 Session 队列与统计、打分逻辑。
- **NoteSlice**：当前打开笔记的内容与 Metadata，以及当前聚焦的 `clozeIndex`。
- **UISlice**：视图模式（library/review/test/master/edit/summary）、主题等 UI 偏好。
- **SmartQueueSlice**：基于 FSRS 的到期队列、搜索、挂起/重置等高级操作。

下文按 slice 逐一说明关键字段与方法。

---

## 3. ServiceSlice：数据服务与认证

来源：[createServiceSlice](cci:1://file:///d:/memory-player/src/store/appStore.ts:181:0-256:3)。

### 3.1 状态字段

- `dataService: DataService`
  - 当前使用的后端实现（`MockAdapter` 或 [SupabaseAdapter](cci:2://file:///d:/memory-player/src/lib/storage/SupabaseAdapter.ts:7:0-892:1)）。
- `syncMode: 'mock' | 'supabase'`
  - 标记当前运行模式，影响一些统计字段（如 `pendingSyncCount`）。
- `currentUser: { id: string; email?: string | null } | null`
  - Supabase 模式下的当前用户信息。
- `lastSyncAt: Date | null`
  - 最近一次成功同步（或成功保存复习）的时间戳。
- `lastServerSyncAt: string | null`
  - 最近一次从后端拉取元数据时，服务端返回的时间游标（由 `DataService.getAllMetadata` 的 `serverNow` 提供）。
  - 作为增量同步的 `after` 参数使用，尽量避免仅依赖本地时间导致的时钟漂移漏数。
- `authCheckCounter: number`
  - 一个简单的计数器，用于触发依赖 `useEffect` 的重新认证检查。

### 3.2 核心方法

- [initDataService(type: 'mock' | 'supabase')](cci:1://file:///d:/memory-player/src/store/appStore.ts:189:2-221:3)
  - 动态 `import` 对应的 Adapter 并调用 [init()](cci:1://file:///d:/memory-player/src/lib/storage/types.ts:37:2-40:23)。
  - 若为 Supabase 模式，自动获取用户信息。
  - 成功后串行调用：[loadVaults()](cci:1://file:///d:/memory-player/src/store/appStore.ts:326:2-341:3) → 确定 `currentVault` 后再调用 [loadAllMetadata()](cci:1://file:///d:/memory-player/src/store/appStore.ts:313:2-324:3) → [loadReviewHistory()](cci:1://file:///d:/memory-player/src/store/appStore.ts:464:2-480:3)。
- [signOut()](cci:1://file:///d:/memory-player/src/store/appStore.ts:227:2-251:3)
  - 登出 Supabase 并强制退回本地 Mock 模式，重置所有库相关状态。

---

## 4. VaultSlice：Vault、文件与元数据

来源：[createVaultSlice](cci:1://file:///d:/memory-player/src/store/appStore.ts:258:0-458:3)。

### 4.1 状态字段

- `rootPath: string | null`：当前 Vault 根路径。
- `files: string[]`：当前 Vault 下的文件列表。
- `fileMetadatas: Record<string, NoteMetadata>`：以 `filepath` 为 key 的笔记元数据（含 FSRS 卡片状态）。
- `idMap` / `pathMap`：`noteId ↔ filepath` 的双向映射。
- `contentCache`：LRU 策略的文件内容缓存（上限 200 条）。
- `vaults` / `currentVault`：Vault 列表与当前选中项。

### 4.2 核心方法

- [setRootPath(path)](cci:1://file:///d:/memory-player/src/store/appStore.ts:290:2-300:3)
  - 切换 Vault，维护 `recentVaults` 历史，重置 `contentCache`。
- [loadAllMetadata()](cci:1://file:///d:/memory-player/src/store/appStore.ts:313:2-324:3)
  - 依赖 `currentVault`：若未选中 Vault 则跳过加载，避免对所有用户数据做全表扫描。
  - 使用 `lastServerSyncAt` 作为「增量游标」：
    - 若 `lastServerSyncAt === null`：视为**首次全量同步**（Full Sync）。
    - 否则：视为**增量同步**（Incremental Sync），仅请求自上次游标之后有变动的卡片/笔记。
  - 调用 `dataService.getAllMetadata(currentVault.id, after)`：
    - 返回 `{ items: NoteMetadata[], serverNow: string }`：
      - `items`：一批受影响的笔记元数据；
      - `serverNow`：由适配器计算出的最新更新时间戳，用于更新 `lastServerSyncAt`。
  - 合并策略（伪代码）：
    - 初始化 `next = { ...state.fileMetadatas }`；
    - 遍历远端 `items`：
      - 若 `m.isDeleted === true`：
        - 视为「整篇笔记被软删」，删除 `next[m.filepath]`（若存在），然后跳过该条；
      - 否则：
        - 若本地不存在该文件：`next[m.filepath] = m`；
        - 若本地已存在：
          - 创建 `mergedCards = { ...existing.cards }`；
          - 遍历 `m.cards`：
            - 若某条 `card` 带有 `(card as any).isDeleted === true`：从 `mergedCards` 中删除对应 `clozeIndex`（单卡软删）；
            - 否则：覆盖/插入该 `clozeIndex` 的 Card；
          - 生成新的 `next[m.filepath] = { ...existing, ...m, cards: mergedCards }`。
    - 最终 `set({ fileMetadatas: next, lastServerSyncAt: serverNow })`，将服务端游标前移。
  - 对于全量同步场景，目前实现倾向于**保守合并**：不主动删除「本地存在但远端未返回」的条目，以避免误删本地仅存在的草稿或 Demo 数据；真正的删除靠远端显式返回 `isDeleted` 的变更来驱动。
- [handleExternalCardUpdate(row)](cci:1://file:///d:/memory-player/src/store/appStore.ts:347:2-457:3) **[关键]**
  - 处理 Supabase Realtime 推送的 `cards` 表更新。
  - 逻辑：
    1. 将 `note_id` 映射回本地 `filepath`。
    2. 比较新旧 Card 的 FSRS 关键字段（state/stability/due）。

---

## 5. SessionSlice：复习队列与打分

来源：[createSessionSlice](cci:1://file:///d:/memory-player/src/store/appStore.ts:483:0-637:3)。

### 5.1 状态字段

- `queue: QueueItem[]`：当前复习队列（每项即一个 Cloze）。
- `sessionIndex`：当前进度索引。
- `sessionStats`：本轮复习的统计（计数、耗时、各档评分分布）。
- `isGrading`：防抖标记位。

### 5.2 核心方法

- [startSession()](cci:1://file:///d:/memory-player/src/store/appStore.ts:492:2-510:3)
  - 初始化统计，加载队列第一张卡片，进入 `test` 视图模式。
- [saveReview(rating: 1|2|3|4)](cci:1://file:///d:/memory-player/src/lib/storage/types.ts:69:2-77:91) **[FSRS 调度核心]**
  - 流程：
    1. 调用 `ts-fsrs` 的 `f.repeat(card, now)` 计算新状态。
    2. 乐观更新本地状态（`currentMetadata` + `fileMetadatas`）。
    3. 调用 [dataService.saveReview](cci:1://file:///d:/memory-player/src/lib/storage/types.ts:69:2-77:91) 持久化到后端。
    4. 记录 `lastLocalReview` 以过滤随后的 Realtime 回流。
    5. 自动加载下一张卡片或结束 Session。

---

## 6. NoteSlice：当前笔记

来源：[createNoteSlice](cci:1://file:///d:/memory-player/src/store/appStore.ts:639:0-789:3)。

### 6.1 状态字段

- `currentFilepath`
- `currentNote`：解析后的结构（Frontmatter + Content + Clozes）。
- `currentMetadata`：当前笔记的 FSRS 数据。
- `currentClozeIndex`：**当前聚焦的题目**（为 null 时表示浏览整篇）。

### 6.2 核心方法

- [loadNote(filepath, targetClozeIndex)](cci:1://file:///d:/memory-player/src/store/appStore.ts:645:2-786:3)
  - 优先读缓存，无缓存则读文件系统。
  - 确保 Frontmatter 中存在 `mp-id`（Note ID），建立 ID 映射。
  - 解析 Markdown。
  - 从 `fileMetadatas` 或 `dataService` 获取最新 FSRS 状态。
  - 设置 `viewMode`（如 `review` 或 `edit`）。

---

## 7. DataService 与 SupabaseAdapter 实现

### 7.1 核心职责

SupabaseAdapter 将 FSRS 逻辑映射到关系型数据库：

1.  **Note 同步 ([syncNote](cci:1://file:///d:/memory-player/src/lib/storage/types.ts:49:2-52:94))**
    - 计算 `content_hash` 跳过未变动文件。
    - 将 Markdown 内容拆解为多个 Card 行（`flattenToCards`）。
    - **Upsert 策略**：
      - `note_id` + `cloze_index` 是唯一键。
      - 若内容变动较大（相似度 < 0.6），自动对 `stability` 施加惩罚。
      - 始终保留已有的 FSRS 调度状态（不覆盖 due/state）。
    - 对「不再出现在笔记中的旧 cloze」不再物理删除，而是：
      - 将对应 `cards` 行更新为 `is_deleted = true, updated_at = now()`；
      - 若整篇笔记完全没有卡片，则对该 Note 下所有 Card 执行软删。
    - 配合 `cards.is_deleted` 字段与部分唯一索引 `uq_card_identity_active (note_id, cloze_index) WHERE is_deleted = false`，实现：
      - 允许在原有 cloze 被软删后「重生」同一 `cloze_index`；
      - 通过 `updated_at` + `is_deleted` 支持增量删除同步。

2.  **复习保存 ([saveReview](cci:1://file:///d:/memory-player/src/lib/storage/types.ts:69:2-77:91))**
    - 使用 RPC `submit_review` 进行事务操作：
      - 更新 `cards` 表状态。
      - 插入 `review_logs` 表历史。

3.  **智能队列 ([getDueCards](cci:1://file:///d:/memory-player/src/lib/storage/types.ts:105:2-110:51))**
    - 筛选条件：`due <= now` AND `is_suspended = false` AND `is_deleted = false` AND `notes.is_deleted = false`。
    - **Vault 隔离**：支持传入 `vaultId`，通过 `notes!inner` 连接强制过滤属于该 Vault 的卡片。
    - 联表查询 `notes` 获取文件路径。

4.  **增量元数据拉取 ([getAllMetadata](cci:1://file:///d:/memory-player/src/lib/storage/types.ts:92:2-98:103))**
    - 统一由 `DataService` 暴露：`getAllMetadata(vaultId?: string, after?: string | Date | null): Promise<{ items: NoteMetadata[], serverNow: string }>`。
    - Supabase 实现：
      - 以 `cards` 为主表，`notes` 为联表：`from('cards').select('*, notes(...)')`；
      - 当 `after` 为空：
        - 仅返回「活跃」数据：`cards.is_deleted = false AND notes.is_deleted = false`；
      - 当 `after` 不为空（增量模式）：
        - 通过 `cards.updated_at > after` 过滤出自上次游标之后被新增/更新/软删的 Card；
        - 包含以下几类变更：
          - 笔记内容变动 -> 对应卡片 `is_deleted = false, updated_at = now()`；
          - 单个 cloze 被删除 -> 对应卡片 `is_deleted = true, updated_at = now()`；
          - 整篇笔记被软删 ([softDeleteNote](cci:1://file:///d:/memory-player/src/lib/storage/SupabaseAdapter.ts:157:2-185:3)) -> Note 标记 `notes.is_deleted = true`，同时该 Note 下所有 Card 标记 `is_deleted = true, updated_at = now()`。
      - 查询结果按 `note_id` 折叠为若干 `NoteMetadata`：
        - `NoteMetadata.isDeleted` 反映 `notes.is_deleted`，用于 VaultSlice 决定整篇笔记是否从缓存移除；
        - 每个 `cards[clozeIndex]` 上可能带有 `(card as any).isDeleted` 标记，用于 VaultSlice 的单卡级删除合并逻辑。
      - `serverNow` 目前实现为本次结果集中最大的 `cards.updated_at`，若结果为空则退化为客户端当前时间（仍存在少量时钟漂移风险，但比单纯使用本地时间更稳健）。

    - MockAdapter 实现：
      - 忽略 `vaultId`/`after` 参数，始终返回当前内存中所有未软删的条目；
      - `serverNow` 简单取本地 `new Date().toISOString()`，仅用作游标推进占位。

### 7.2 数据库表结构映射

- `notes`: 存储文件元数据（path, title, tags, hash）。
- `review_logs`: 存储每次打分的详细记录。
- `vaults`: 存储用户库配置。

---

## 8. 典型数据流


1.  **启动**：[initDataService](cci:1://file:///d:/memory-player/src/store/appStore.ts:189:2-221:3) -> [loadVaults](cci:1://file:///d:/memory-player/src/store/appStore.ts:326:2-341:3) -> [loadAllMetadata](cci:1://file:///d:/memory-player/src/store/appStore.ts:313:2-324:3)。
2.  **复习**：`Dashboard` 生成队列 -> [startSession](cci:1://file:///d:/memory-player/src/store/appStore.ts:492:2-510:3) -> [loadNote](cci:1://file:///d:/memory-player/src/store/appStore.ts:645:2-786:3) -> 用户打分 -> [saveReview](cci:1://file:///d:/memory-player/src/lib/storage/types.ts:69:2-77:91) (FSRS calc) -> RPC 写库 -> 加载下一张。
3.  **同步**：本地保存文件 -> `FileSystemWatcher` -> [syncNote](cci:1://file:///d:/memory-player/src/lib/storage/types.ts:49:2-52:94) -> 计算 Hash -> Upsert `cards`.
4.  **多端**：端 A 复习 -> Supabase 更新 -> 端 B 收到 Realtime -> [handleExternalCardUpdate](cci:1://file:///d:/memory-player/src/store/appStore.ts:347:2-457:3) -> 更新端 B 内存状态。

---

## 9. 单文件元数据刷新：refreshMetadata

### 9.1 设计动机

早期版本中，`VaultWatcher` 在监听到文件变更并调用 `syncNote` 后，**并不会立即刷新该文件对应的 `fileMetadatas`**，导致：

- Supabase 队列（`getDueCards`）已经包含新卡 / 更新后的 due;
- 但本地 `Dashboard` / `LibraryView` 仍使用旧的 `fileMetadatas`，`Due Today` 分组不会实时更新。

为解决这一不一致，引入全局 helper：

```ts
refreshMetadata(filepath: string, noteIdOverride?: string): Promise<void>
```

### 9.2 行为定义

`refreshMetadata` 位于 `VaultSlice` 中，职责：

- 使用 `dataService.getMetadata(noteId, filepath)` 拉取**单个笔记**的最新 FSRS 元数据;
- 维护以下不变式：
  - `files` 一定包含 `filepath`;
  - `idMap[noteId] = filepath`;
  - `pathMap[filepath] = noteId`;
  - `fileMetadatas[filepath]` 更新为最新的 `NoteMetadata`（并补上 `noteId`）。

Note ID 的推断顺序：

1. 调用方传入的 `noteIdOverride`;
2. 现有的 `pathMap[filepath]`;
3. 现有的 `fileMetadatas[filepath]?.noteId`;
4. 否则为空字符串（由后端自行解析 / 容错）。

### 9.3 VaultWatcher 的使用方式

`useVaultWatcher` 在监听到 `.md` 文件变更时：

1. 调用 `fileSystem.ensureNoteId(path)` 获取 `id` 和最新内容;
2. 调用 `dataService.syncNote(path, content, id, currentVault?.id)` 将笔记同步到后端;
3. 调用 `updateLastSync()` 更新同步时间;
4. 调用 `refreshMetadata(path, id)`：
   - 确保该文件已经注册在 `files`/`idMap`/`pathMap`;
   - 立刻刷新该文件的 FSRS 元数据到 `fileMetadatas[path]`。

这样，**外部编辑器（如 Obsidian）保存后的新卡/更新卡，会立即出现在 Dashboard 的 `Due Today` 和 Library 的分组中**，无需再全量调用 `loadAllMetadata`。

---

## 10. 分组规则（Dashboard / Library）

### 10.1 Dashboard（`Dashboard.tsx`）

`dashboardData` 聚合时，对每张卡的处理规则：

- 统计 FSRS 状态：
  - `state === 0` 记入 `stats.new`;
  - `state === 1/2/3` 依次计入 `learning/review/relearning`;
- **新卡 (state === 0)**：
  - 永远计入 `newItems`;
  - 若 `due <= now`：
    - 同时计入 `dueItems`;
    - 若 `differenceInDays(now, due) >= 1` 再计入 `overdueItems`;
    - `futureCounts[today]++`;
  - 若 `due > now`：
    - 仅更新 `futureCounts[format(due, 'yyyy-MM-dd')]++`;
- **已学习/复习中的卡 (state > 0)**：
  - 若 `due <= now`：计入 `dueItems` / `overdueItems`;
  - 若 `due > now`：仅计入 `futureCounts[dateKey]`。

> 结果：**“今天到期的新卡” 同时出现在 `New` 和 `Due Today` 统计中**，更符合用户对「今天任务量」的直觉。

### 10.2 LibraryView（`LibraryView.tsx`）

Library 的文件分组基于每个文件下所有卡片：

- 预处理：
  - 若该文件没有 `meta.cards` 或卡片数组为空 → 视为 `New`;
- 对每张卡：
  - 若没有 `due` 或 `due` 非法：
    - 若 `reps === 0`，视为 `New`;
  - 否则解析 `due` 为日期：
    - 若 `reps === 0`：
      - `isToday(due)` → 文件打标 `hasToday = true`;
      - 否则 → 文件打标 `hasNew = true`;
    - 若 `reps > 0`：
      - `isPast(due) && !isToday(due)` → `hasOverdue = true`;
      - `isToday(due)` → `hasToday = true`。
- 最终分组优先级：
  1. `hasOverdue` → `Overdue`;
  2. 否则 `hasToday` → `Due Today`;
  3. 否则 `hasNew` → `New Cards`;
  4. 否则 → `Library`（未来到期）。

这样，“第一次同步的新卡，只要 due 在今天或过去”，会被归入 `Due Today` 而不是长期停留在 `New Cards`，与 Dashboard 显示保持一致。