# 状态管理设计（Memory Player）

本文记录当前项目在 **全局状态管理** 与 **数据同步层（Supabase/Mock）** 上的技术设计，主要依据：

- [src/store/appStore.ts](cci:7://file:///d:/memory-player/src/store/appStore.ts:0:0-0:0)
- [src/lib/storage/SupabaseAdapter.ts](cci:7://file:///d:/memory-player/src/lib/storage/SupabaseAdapter.ts:0:0-0:0)
- [src/lib/storage/types.ts](cci:7://file:///d:/memory-player/src/lib/storage/types.ts:0:0-0:0)
- 以及辅助文档 [docs/DEVELOPER_GUIDE_FSRS_FLOW.md](cci:7://file:///d:/memory-player/docs/DEVELOPER_GUIDE_FSRS_FLOW.md:0:0-0:0)

---

## 1. 技术栈与总体思路

- **状态管理库**：Zustand
  - 单一全局 store：`useAppStore`。
  - 通过 `devtools` + `persist` 中间件增强：
    - `devtools`：配合浏览器 DevTools 调试。
    - `persist`：持久化少量 UI/路径配置（如 `rootPath`、`recentVaults`、`files`、`theme`），以及部分轻量数据层状态（如 `fileMetadatas`、`lastServerSyncAt`），用于离线/乐观展示。
- **数据服务抽象**：[DataService](cci:2://file:///d:/memory-player/src/lib/storage/types.ts:36:0-127:1) 接口
  - 由 `MockAdapter`（本地开发/离线）与 [SupabaseAdapter](cci:2://file:///d:/memory-player/src/lib/storage/SupabaseAdapter.ts:7:0-892:1)（云端）实现。
  - 上层 `appStore` 不关心具体实现，只通过统一方法读写元数据与 FSRS 状态。
- **FSRS 调度粒度**：
  - 一条 **Card = 一个 Cloze**。

**核心原则**：
- `useAppStore` 负责 App 级别的 UI/Session 状态与 DataService 调用。
- [DataService](cci:2://file:///d:/memory-player/src/lib/storage/types.ts:36:0-127:1) 负责「笔记 → 卡片 → FSRS 状态 → 历史」的持久化与同步。

---

## 2. AppState 结构总览

[AppState](cci:2://file:///d:/memory-player/src/store/appStore.ts:21:0-93:1) 将状态按领域拆分为多个 slice：

- **ServiceSlice**：当前数据服务、登录/同步信息。
- **VaultSlice**：本地库（Vault）、文件列表、元数据、内容缓存、Note ID 映射.
- **HistorySlice**：复习历史与待同步计数.
- **SessionSlice**：当前复习 Session 队列与统计、打分逻辑.
- **NoteSlice**：当前打开笔记的内容与 Metadata，以及当前聚焦的 `clozeIndex`.
- **UISlice**：视图模式（library/review/test/master/edit/summary）、主题等 UI 偏好.
- **SmartQueueSlice**：基于 FSRS 的到期队列、搜索、挂起/重置等高级操作.

下文按 slice 逐一说明关键字段与方法。

---

## 3. ServiceSlice：数据服务与认证

来源：[createServiceSlice](cci:1://file:///d:/memory-player/src/store/appStore.ts:181:0-256:3)。

### 3.1 状态字段

- `dataService: DataService`
  - 当前使用的后端实现（`MockAdapter` 或 [SupabaseAdapter](cci:2://file:///d:/memory-player/src/lib/storage/SupabaseAdapter.ts:7:0-892:1)）。
- `syncMode: 'mock' | 'supabase'`
  - 标记当前运行模式，影响一些统计字段（如 `pendingSyncCount`）。
- `currentUser: { id: string; email?: string | null } | null`
  - Supabase 模式下的当前用户信息.
- `lastSyncAt: Date | null`
  - 最近一次成功同步（或成功保存复习）的时间戳.
- `lastServerSyncAt: string | null`
  - 最近一次从后端拉取元数据时，服务端返回的时间游标（由 `DataService.getAllMetadata` 的 `serverNow` 提供）。
  - 作为增量同步的 `after` 参数使用，尽量避免仅依赖本地时间导致的时钟漂移漏数.
- `authCheckCounter: number`
  - 一个简单的计数器，用于触发依赖 `useEffect` 的重新认证检查.

### 3.2 核心方法

- [initDataService(type: 'mock' | 'supabase')](cci:1://file:///d:/memory-player/src/store/appStore.ts:189:2-221:3)
  - 动态 `import` 对应的 Adapter 并调用 [init()](cci:1://file:///d:/memory-player/src/lib/storage/types.ts:37:2-40:23)。
  - 若为 Supabase 模式，尝试通过 Supabase 客户端获取当前用户并写入 `currentUser`.
  - 完成后仅更新 `dataService` / `syncMode` / `currentUser` / `lastSyncAt`，**不再在函数内部主动调用** `loadVaults` / `loadAllMetadata` / `loadReviewHistory`，以保证启动关键路径尽量轻量；后续数据加载交由 LibraryView / Dashboard 等视图按需触发.
  - 若存在 Supabase 会话，还会在后台做一次 `auth.getUser()` 复检，失败时触发自动登出与 Toast 提示.
- [signOut()](cci:1://file:///d:/memory-player/src/store/appStore.ts:227:2-251:3)
  - 登出 Supabase 并强制退回本地 Mock 模式，重置所有库相关状态.

---

## 4. VaultSlice：Vault、文件与元数据

来源：[createVaultSlice](cci:1://file:///d:/memory-player/src/store/appStore.ts:258:0-458:3)。

### 4.1 状态字段

- `rootPath: string | null`：当前 Vault 根路径.
- `files: string[]`：当前 Vault 下的文件列表.
- `fileMetadatas: Record<string, NoteMetadata>`：以 `filepath` 为 key 的笔记元数据（含 FSRS 卡片状态）。
- `idMap` / `pathMap`：`noteId ↔ filepath` 的双向映射.
- `contentCache`：LRU 策略的文件内容缓存（上限 200 条）。
- `vaults` / `currentVault`：Vault 列表与当前选中项.

### 4.2 核心方法

- [setRootPath(path)](cci:1://file:///d:/memory-player/src/store/appStore.ts:290:2-300:3)
  - 切换 Vault，维护 `recentVaults` 历史，重置 `contentCache`.
- [loadAllMetadata()](cci:1://file:///d:/memory-player/src/store/appStore.ts:455:2-523:3)
  - 依赖 `currentVault`：若未选中 Vault 则跳过加载，避免对所有用户数据做全表扫描.
  - 使用 `lastServerSyncAt` 作为「增量游标」：
    - 若 `lastServerSyncAt === null`：视为**首次全量同步**（Full Sync）。
    - 否则：视为**增量同步**（Incremental Sync），仅请求自上次游标之后有变动的卡片/笔记.
  - 调用 `dataService.getAllMetadata(currentVault.id, after)`：
    - 返回 `{ items: NoteMetadata[], serverNow: string }`：
      - `items`：一批受影响的笔记元数据；
      - `serverNow`：由适配器计算出的最新更新时间戳，用于更新 `lastServerSyncAt`.
  - 合并策略（伪代码）：
    - 初始化 `next = { ...state.fileMetadatas }`；
    - 遍历远端 `items`：
      - 若 `m.isDeleted === true`：
        - 视为「整篇笔记被软删」，删除 `next[m.filepath]`（若存在），然后跳过该条；
      - 否则：
        - 若本地不存在该文件：`next[m.filepath] = m`；
        - 若本地已存在：
          - 创建 `mergedCards = { ...existing.cards }`；
          - 遍历 `m.cards`：
            - 若某条 `card` 带有 `(card as any).isDeleted === true`：从 `mergedCards` 中删除对应 `clozeIndex`（单卡软删）；
            - 否则：覆盖/插入该 `clozeIndex` 的 Card；
          - 生成新的 `next[m.filepath] = { ...existing, ...m, cards: mergedCards }`。
    - 最终 `set({ fileMetadatas: next, lastServerSyncAt: serverNow })`，将服务端游标前移.
  - 对于全量同步场景，目前实现倾向于**保守合并**：不主动删除「本地存在但远端未返回」的条目，以避免误删本地仅存在的草稿或 Demo 数据；真正的删除靠远端显式返回 `isDeleted` 的变更来驱动.
- [handleExternalCardUpdate(row)](cci:1://file:///d:/memory-player/src/store/appStore.ts:635:2-745:3) **[关键]**
  - 处理 Supabase Realtime 推送的 `cards` 表更新.
  - 逻辑：
    1. 将 `note_id` 映射回本地 `filepath`.
    2. 比较新旧 Card 的 FSRS 关键字段（state/stability/due）。

---

## 5. SessionSlice：复习队列与打分

来源：[createSessionSlice](cci:1://file:///d:/memory-player/src/store/appStore.ts:483:0-637:3)。

### 5.1 状态字段

- `queue: QueueItem[]`：当前复习队列（每项即一个 Cloze）。
- `sessionIndex`：当前进度索引.
- `sessionStats`：本轮复习的统计（计数、耗时、各档评分分布）。
- `isGrading`：防抖标记位.

### 5.2 核心方法

- [startSession()](cci:1://file:///d:/memory-player/src/store/appStore.ts:492:2-510:3)
  - 初始化统计，加载队列第一张卡片，进入 `test` 视图模式.
- [saveReview(rating: 1|2|3|4)](cci:1://file:///d:/memory-player/src/lib/storage/types.ts:69:2-77:91) **[FSRS 调度核心]**
  - 流程：
    1. 调用 `ts-fsrs` 的 `f.repeat(card, now)` 计算新状态.
    2. 乐观更新本地状态（`currentMetadata` + `fileMetadatas`）。
    3. 调用 [dataService.saveReview](cci:1://file:///d:/memory-player/src/lib/storage/types.ts:69:2-77:91) 持久化到后端.
    4. 记录 `lastLocalReview` 以过滤随后的 Realtime 回流.
    5. 自动加载下一张卡片或结束 Session.

---

## 6. NoteSlice：当前笔记

来源：[createNoteSlice](cci:1://file:///d:/memory-player/src/store/appStore.ts:639:0-789:3).

### 6.1 状态字段

- `currentFilepath`
- `currentNote`：解析后的结构（Frontmatter + Content + Clozes）。
- `currentMetadata`：当前笔记的 FSRS 数据.
- `currentClozeIndex`：**当前聚焦的题目**（为 null 时表示浏览整篇）。

### 6.2 核心方法

- [loadNote(filepath, targetClozeIndex)](cci:1://file:///d:/memory-player/src/store/appStore.ts:1015:2-1061:3)
  - 通过若干内部 helper 组合完成，逻辑上可拆为 4 步：
    1. **内容加载（loadContentFromSource）**：
       - 先查 `contentCache`，命中则直接返回；
       - 若当前 Vault 为 `DEMO_VAULT`，使用内置 Demo 模板生成 Markdown 内容，同时复用已有的 `pathMap[filepath]` 作为 `noteId`（若存在）；
       - 否则在桌面环境下调用 `fileSystem.ensureNoteId(filepath)`：
         - 返回最新文件内容；
         - 确保 Frontmatter 中存在稳定的 Note ID；
         - 若发现新的 Note ID，则后续会写入 `idMap` / `pathMap`.
    2. **缓存与 ID 映射更新（updateCacheAndIds）**：
       - 维护 `contentCache` 的 LRU 行为（上限 `MAX_CONTENT_CACHE_ENTRIES` 条）；
       - 只要拿到了合法的 `noteId`，就确保：
         - `idMap[noteId] = filepath`；
         - `pathMap[filepath] = noteId`；
       - 这一点保证了 Demo / 本地文件 / Supabase 三种场景下，Note ID 映射的行为保持一致.
    3. **解析与视图状态更新**：
       - 使用 `parseNote(content)` 解析 Markdown，得到 `currentNote`；
       - 根据当前全局 `viewMode` 选择目标模式：
         - 若当前模式属于 `['edit', 'test', 'master']`，则保持不变；
         - 否则进入 `review` 模式；
       - 将 `currentFilepath` / `currentNote` / `currentMetadata`（优先使用现有 `fileMetadatas[filepath]` 缓存） / `currentClozeIndex` 一次性写入 store；
       - 若 `targetClozeIndex` 非空且处于 `test`/`review` 模式，启动当前卡片的复习计时器 `currentReviewStartTime`，否则清空该计时.
    4. **元数据同步（syncNoteMetadata）**：
       - 调用 `dataService.getMetadata(noteId || '', filepath)` 获取该笔记的最新 FSRS 元数据；
       - 若已经握有 `noteId`，则强制写回 `metadata.noteId = noteId`；
       - 合并到 `fileMetadatas[filepath]`，并在 `currentFilepath === filepath` 时同步刷新 `currentMetadata`.

  - **对外语义**：
    - 仍然遵循「优先本地缓存，其次文件系统 / Demo 内容，最终从数据服务拉取 FSRS 状态」的流程；
    - 通过 helper 函数拆分复杂度，使得 `loadNote` 本身更易于单元测试和维护，但不会改变调用方对其行为的预期.

- `saveCurrentNote(content: string)`
  - 封装「本地保存 + 内存缓存更新 + 后台同步 + `refreshMetadata`」的一站式操作：
    - 调用 `fileSystem.writeNote(currentFilepath, content)` 将当前笔记写入本地；
    - 按 `MAX_CONTENT_CACHE_ENTRIES` 规则维护 `contentCache` 的 LRU 行为，并立即用 `parseNote(content)` 刷新 `currentNote`；
    - 若存在 `pathMap[currentFilepath]` 与有效 `dataService`：
      - 调用 `dataService.syncNote(currentFilepath, content, noteId, currentVault?.id)` 将内容同步到后端；
      - 成功时更新 `lastSyncAt`、调用 `markNoteSynced` 并通过 `refreshMetadata(filepath, noteId)` 刷新该笔记的 FSRS 元数据；
      - 失败时调用 `markNoteSyncPending` 并通过 Toast 提示 "Cloud sync failed (saved locally)"，保证本地保存不丢失的同时给出清晰反馈.
  - 目前主要由 `EditMode.handleSave` 调用，替代了组件内手写的保存 + 同步管线逻辑，使保存行为在 store 层集中管理.

---

## 7. DataService 与 SupabaseAdapter 实现

### 7.1 核心职责

SupabaseAdapter 将 FSRS 逻辑映射到关系型数据库：

1.  **Note 同步 ([syncNote](cci:1://file:///d:/memory-player/src/lib/storage/types.ts:49:2-52:94))**
    - 计算 `content_hash` 跳过未变动文件.
    - 将 Markdown 内容拆解为多个 Card 行（`flattenToCards`）。
    - **Upsert 策略**：
      - `note_id` + `cloze_index` 是唯一键.
      - 若内容变动较大（相似度 < 0.6），自动对 `stability` 施加惩罚.
      - 始终保留已有的 FSRS 调度状态（不覆盖 due/state）。
    - 对「不再出现在笔记中的旧 cloze」不再物理删除，而是：
      - 将对应 `cards` 行更新为 `is_deleted = true, updated_at = now()`；
      - 若整篇笔记完全没有卡片，则对该 Note 下所有 Card 执行软删.
    - 配合 `cards.is_deleted` 字段与部分唯一索引 `uq_card_identity_active (note_id, cloze_index) WHERE is_deleted = false`，实现：
      - 允许在原有 cloze 被软删后「重生」同一 `cloze_index`；
      - 通过 `updated_at` + `is_deleted` 支持增量删除同步.

2.  **复习保存 ([saveReview](cci:1://file:///d:/memory-player/src/lib/storage/types.ts:69:2-77:91))**
    - 使用 RPC `submit_review` 进行事务操作：
      - 更新 `cards` 表状态.
      - 插入 `review_logs` 表历史.

3.  **智能队列 ([getDueCards](cci:1://file:///d:/memory-player/src/lib/storage/types.ts:105:2-110:51))**
    - 筛选条件：`due <= now` AND `is_suspended = false` AND `is_deleted = false` AND `notes.is_deleted = false`.
    - **Vault 隔离**：支持传入 `vaultId`，通过 `notes!inner` 连接强制过滤属于该 Vault 的卡片.
    - 联表查询 `notes` 获取文件路径.

4.  **增量元数据拉取 ([getAllMetadata](cci:1://file:///d:/memory-player/src/lib/storage/types.ts:92:2-98:103))**
    - 统一由 `DataService` 暴露：`getAllMetadata(vaultId?: string, after?: string | Date | null): Promise<{ items: NoteMetadata[], serverNow: string }>`.
    - Supabase 实现：
      - 以 `cards` 为主表，`notes` 为联表：`from('cards').select('*, notes(...)')`；
      - 当 `after` 为空：
        - 仅返回「活跃」数据：`cards.is_deleted = false AND notes.is_deleted = false`；
      - 当 `after` 不为空（增量模式）：
        - 通过 `cards.updated_at > after` 过滤出自上次游标之后被新增/更新/软删的 Card；
        - 包含以下几类变更：
          - 笔记内容变动 -> 对应卡片 `is_deleted = false, updated_at = now()`；
          - 单个 cloze 被删除 -> 对应卡片 `is_deleted = true, updated_at = now()`；
          - 整篇笔记被软删 ([softDeleteNote](cci:1://file:///d:/memory-player/src/lib/storage/SupabaseAdapter.ts:157:2-185:3)) -> Note 标记 `notes.is_deleted = true`，同时该 Note 下所有 Card 标记 `is_deleted = true, updated_at = now()`.
      - 查询结果按 `note_id` 折叠为若干 `NoteMetadata`：
        - `NoteMetadata.isDeleted` 反映 `notes.is_deleted`，用于 VaultSlice 决定整篇笔记是否从缓存移除；
        - 每个 `cards[clozeIndex]` 上可能带有 `(card as any).isDeleted` 标记，用于 VaultSlice 的单卡级删除合并逻辑.
      - `serverNow` 目前实现为本次结果集中最大的 `cards.updated_at`，若结果为空则退化为客户端当前时间（仍存在少量时钟漂移风险，但比单纯使用本地时间更稳健）。

    - MockAdapter 实现：
      - 忽略 `vaultId`/`after` 参数，始终返回当前内存中所有未软删的条目；
      - `serverNow` 简单取本地 `new Date().toISOString()`，仅用作游标推进占位.

### 7.2 数据库表结构映射

- `notes`: 存储文件元数据（path, title, tags, hash）。
- `review_logs`: 存储每次打分的详细记录.
- `vaults`: 存储用户库配置.

---

## 8. 典型数据流

1.  **启动**：`AuthGate` 调用 [initDataService](cci:1://file:///d:/memory-player/src/store/appStore.ts:189:2-221:3) 仅初始化 `dataService` 与解析当前用户；用户进入 `LibraryView` 后，由 `LibraryView` 通过 `loadSettings` / [loadVaults](cci:1://file:///d:/memory-player/src/store/appStore.ts:604:2-626:3) 选定 `currentVault`，再由 [loadAllMetadata](cci:1://file:///d:/memory-player/src/store/appStore.ts:455:2-523:3) 基于 `currentVault` + `lastServerSyncAt` 懒加载/增量拉取元数据；进入 Dashboard 时，由 `Dashboard` 通过 [loadReviewHistory](cci:1://file:///d:/memory-player/src/store/appStore.ts:752:2-769:3) 懒加载最近 365 天复习历史.
2.  **复习**：`Dashboard` 生成队列 -> [startSession](cci:1://file:///d:/memory-player/src/store/appStore.ts:826:2-843:3) -> [loadNote](cci:1://file:///d:/memory-player/src/store/appStore.ts:1170:2-1207:3)（内部通过 `loadContentFromSource` / `updateCacheAndIds` / `syncNoteMetadata` 完成加载与同步）-> 用户打分 -> [saveReview](cci:1://file:///d:/memory-player/src/lib/storage/types.ts:69:2-77:91) (FSRS calc) -> RPC 写库 -> 加载下一张.
3.  **同步**：本地保存文件（内置编辑器或外部编辑器） -> `useVaultWatcher` / `useFileWatcher` 监听到 `.md` 变更 -> 通过 `fileSystem.ensureNoteId(path)` 获取 `id` 和最新内容，并调用模块级 helper [syncNoteFromFilesystem](cci:1://file:///d:/memory-player/src/store/appStore.ts:385:0-398:3) -> 由 store 统一执行 `updateCacheAndIds` + `dataService.syncNote` + `updateLastSync` + `markNoteSynced` + `refreshMetadata`.
4.  **多端**：端 A 复习 -> Supabase 更新 -> 端 B 收到 Realtime -> [handleExternalCardUpdate](cci:1://file:///d:/memory-player/src/store/appStore.ts:635:2-745:3) -> 更新端 B 内存状态.

---

## 9. 单文件元数据刷新：refreshMetadata

### 9.1 设计动机

早期版本中，`VaultWatcher` 在监听到文件变更并调用 `syncNote` 后，**并不会立即刷新该文件对应的 `fileMetadatas`**，导致：

- Supabase 队列（`getDueCards`）已经包含新卡 / 更新后的 due;
- 但本地 `Dashboard` / `LibraryView` 仍使用旧的 `fileMetadatas`，`Due Today` 分组不会实时更新.

为解决这一不一致，引入全局 helper：

```ts
refreshMetadata(filepath: string, noteIdOverride?: string): Promise<void>
```

### 9.2 行为定义

`refreshMetadata` 位于 `VaultSlice` 中，职责：

- 使用 `dataService.getMetadata(noteId, filepath)` 拉取**单个笔记**的最新 FSRS 元数据;
- 维护以下不变式：
  - `files` 一定包含 `filepath`;
  - `idMap[noteId] = filepath`;
  - `pathMap[filepath] = noteId`;
  - `fileMetadatas[filepath]` 更新为最新的 `NoteMetadata`（并补上 `noteId`）。

Note ID 的推断顺序：

1. 调用方传入的 `noteIdOverride`;
2. 现有的 `pathMap[filepath]`;
3. 现有的 `fileMetadatas[filepath]?.noteId`;
4. 否则为空字符串（由后端自行解析 / 容错）。

### 9.3 VaultWatcher 的使用方式

`useVaultWatcher` 在监听到 `.md` 文件变更时：

1. 调用 `fileSystem.ensureNoteId(path)` 获取 `id` 和最新内容；
2. 通过模块级 helper [syncNoteFromFilesystem](cci:1://file:///d:/memory-player/src/store/appStore.ts:385:0-398:3) 触发统一的「更新缓存 + 同步到后端 + 更新 `lastSyncAt` + 标记已同步 + `refreshMetadata`」管线，避免在 hook 中直接操作 store；
3. 对删除事件（`kind === 'remove'`），则调用模块级 [softDeleteNoteForPath](cci:1://file:///d:/memory-player/src/store/appStore.ts:391:0-398:3)：基于 `pathMap` 解析 `noteId` 并调用 `dataService.softDeleteNote(noteId)`，再更新 `lastSyncAt`，实现外部删除 → 云端软删的闭环.

这样，**外部编辑器（如 Obsidian）保存后的新卡/更新卡，会立即出现在 Dashboard 的 `Due Today` 和 Library 的分组中**，无需再全量调用 `loadAllMetadata`.

---

## 10. 分组规则（Dashboard / Library）

### 10.1 Dashboard（`Dashboard.tsx`）

`dashboardData` 聚合时，对每张卡的处理规则：

- 统计 FSRS 状态：
  - `state === 0` 记入 `stats.new`;
  - `state === 1/2/3` 依次计入 `learning/review/relearning`;
- **新卡 (state === 0)**：
  - 永远计入 `newItems`;
  - 若 `due <= now`：
    - 同时计入 `dueItems`;
    - 若 `differenceInDays(now, due) >= 1` 再计入 `overdueItems`;
    - `futureCounts[today]++`;
  - 若 `due > now`：
    - 仅更新 `futureCounts[format(due, 'yyyy-MM-dd')]++`;
- **已学习/复习中的卡 (state > 0)**：
  - 若 `due <= now`：计入 `dueItems` / `overdueItems`;
  - 若 `due > now`：仅计入 `futureCounts[dateKey]`.

> 结果：**“今天到期的新卡” 同时出现在 `New` 和 `Due Today` 统计中**，更符合用户对「今天任务量」的直觉.

### 10.2 LibraryView（`LibraryView.tsx`）

Library 的文件分组基于每个文件下所有卡片：

- 预处理：
  - 若该文件没有 `meta.cards` 或卡片数组为空 → 视为 `New`;
- 对每张卡：
  - 若没有 `due` 或 `due` 非法：
    - 若 `reps === 0`，视为 `New`;
  - 否则解析 `due` 为日期：
    - 若 `reps === 0`：
    - 若 `reps > 0`：
      - `isPast(due) && !isToday(due)` → `hasOverdue = true`;
      - `isToday(due)` → `hasToday = true`.
 - 最终分组优先级:
   1. `hasOverdue` → `Overdue`;
   2. 否则 `hasToday` → `Due Today`;
   3. 否则 `hasNew` → `New Cards`;
   4. 否则 → `Library`（未来到期）。

 这样，“第一次同步的新卡，只要 due 在今天或过去”，会被归入 `Due Today` 而不是长期停留在 `New Cards`，与 Dashboard 显示保持一致.

 ## 11. 基于 Zustand 的状态管理优化计划

 ### 11.1 总体方向（对照官方最佳实践）

 - **统一使用 slice + actions 管理业务逻辑**
   - 继续保持当前基于 `createServiceSlice` / `createVaultSlice` / `createSessionSlice` / `createNoteSlice` 等的切片结构，使每个 slice 负责一个清晰的领域.
   - 避免在组件中直接拼装复杂业务流程（例如 FSRS 调度、保存 + 同步管线），而是通过 store actions 或模块级 helper 统一封装，方便测试与演进.

 - **用 selector 优化订阅范围**（官方推荐模式）
   - 尽量避免在组件中直接调用 `useAppStore()`（无 selector），这会订阅整个 AppState，任何字段变动都触发重渲染.
   - 推荐模式：`useAppStore((s) => s.currentNote)` 或 `useAppStore(selector, shallow)` 只订阅必要字段，尤其在 EditMode / Review / Dashboard 等高频渲染视图中收益明显.

 - **区分全局状态与局部 UI 状态**
   - 像 `EditMode` 中的 `activePreviewCloze`、`showShortcuts`、光标位置等纯 UI 状态，继续保留在组件内部（已符合最佳实践）。
   - 只把「跨视图共享、需要持久化或和数据服务强相关」的状态放进 `useAppStore`（如队列、FSRS 元数据、当前 note 元信息等）。

 ### 11.2 appStore.ts 优化方向

 - **[Selector + shallow 渲染优化]**
   - 目前：`EditMode` 已基本改为通过多个 selector（如 `currentNote` / `currentFilepath` 等）读取全局状态，重计算逻辑仍集中在组件本地 `useState` / `useMemo` / `useEffect` 中，整体行为与本节规划一致；其它高频组件（如 Dashboard / Review Player）可继续按此模式演进.
   - 计划：在 `appStore.ts` 中设计并实现统一的笔记保存 action（如 `saveNote` / `saveCurrentNote`），将其它仍在组件内实现的保存/同步流程逐步迁移到 store.

 - **[集中保存/同步流程到 Note/Vault slice]**
   - 目前：在 `createNoteSlice` 中已经实现 `saveCurrentNote(content: string)`，封装「本地写盘 + LRU 缓存更新 + 后台同步 + `refreshMetadata`」的完整管线，`EditMode` 已经迁移为直接调用该 action；外部编辑器场景则通过模块级 helper `syncNoteFromFilesystem` 触发相同的同步 + 刷新逻辑，避免在 hook 内重复实现.
   - 后续：如需支持更复杂的同步场景（批量重试、强制重拉元数据等），可以在 store 层继续扩展相应的 action / helper，而不再在 UI 层手工拼装流程.

 - **[模块级 actions 收敛 useAppStore.setState/getState]**
   - 目前：在部分组件中仍存在直接调用 `useAppStore.setState` / `useAppStore.getState()` 的情况，但对于与文件系统强相关的流程（如 VaultWatcher），已经通过 `syncNoteFromFilesystem` / `softDeleteNoteForPath` 等模块级 helper 收敛到 store 模块内部.
   - 计划：后续可以继续在 `appStore.ts` 中集中定义并导出更细粒度的模块级函数，例如：`export const markNoteSynced = (filepath: string) => useAppStore.getState().markNoteSynced(filepath);`、`export const refreshNoteMetadata = (filepath: string, noteId?: string) => useAppStore.getState().refreshMetadata(filepath, noteId);`。UI 层尽量不直接使用 `setState`，只通过 slice actions 或这些 helper 调用全局状态变更，减少状态更新逻辑的分散与重复.

 - **[FSRS / Session 领域边界进一步明确]**
   - 保持 FSRS 调度、session 队列推进、统计等逻辑完全收敛在 `SessionSlice` / `NoteSlice` 中：UI 只能通过 `startSession` / `saveReview` 等 action 驱动，这一点当前实现已经基本达成.后续若引入更复杂的操作（如「从队列头/尾插入卡片」「按标签过滤队列」），优先在 slice 内新增 action，而不是在组件层直接操作 queue 数组，以维持 store 的单一事实源.

 ### 11.3 EditMode.tsx 与全局 store 协作优化

- **[缩小 EditMode 的全局订阅范围]**
  - 目前：`EditMode` 已基本改为通过多个 selector（如 `currentNote` / `currentFilepath` 等）读取全局状态，重计算逻辑仍集中在组件本地 `useState` / `useMemo` / `useEffect` 中，整体行为与本节规划一致；其它高频组件（如 Dashboard / Review Player）可继续按此模式演进.

- **[统一保存入口，EditMode 只关心 UI 状态]**
  - 目前：`NoteSlice` 中已经提供 `saveCurrentNote(content: string)`：内部完成本地写盘、更新 `contentCache` / `currentNote`、触发 `syncNote` + `refreshMetadata`、更新 `pendingNoteSyncs` 与 `lastSyncAt`。`EditMode.handleSave` 已简化为：校验 `isDirty` 后调用 `saveCurrentNote(content)`，并根据结果管理 `isSaving` 状态和 toast 提示。好处：EditMode 不再依赖 `MAX_CONTENT_CACHE_ENTRIES` 等 store 内部实现细节；未来如需调整缓存策略或同步策略，只需修改 store 层.

- **[元数据刷新策略由 store 统一管理]**
  - 当前：`loadNote` 内通过 `syncNoteMetadata` 异步刷新 `currentMetadata` 与 `fileMetadatas`；`saveCurrentNote` 在成功同步后调用 `refreshMetadata`；`useVaultWatcher` 则通过 `syncNoteFromFilesystem` 统一走同一套刷新逻辑。整体上，FSRS 元数据的刷新时机已经基本由 store 统一管理，UI 只消费结果即可.

 ### 11.4 渐进式落地计划

- **短期（1–2 个迭代）**
  - 在 `EditMode`、Dashboard 等关键页面引入 selector 写法（目前已基本完成），继续替换历史上的 `useAppStore()` 无参调用.
  - 保持并演进统一的笔记保存 action（`saveCurrentNote`），将其它仍在组件内实现的保存/同步流程逐步迁移到 store.

 - **中期（3–5 个迭代）**
   - 系统性排查并收敛所有散落在组件中的 `useAppStore.setState/getState` 调用，替换为 slice actions 或 module-level helpers.
   - 在文档中补充各 slice 的领域边界约定，并标注「哪些状态可以进全局 store，哪些必须保持为局部 UI 状态」，形成团队统一的状态管理规范.
   - 评估是否需要按领域拆分为多个独立 store（例如 `useSessionStore`、`useLibraryStore` 等），或对复杂队列/过滤逻辑采用 redux-style reducer + `dispatch` 模式（zustand 官方支持）。
   - 在拆分或引入新模式时，保持对外 API 的稳定（通过门面函数/自定义 hooks 封装），避免对上层页面造成大规模改动。