# Memory Player 功能实现进度

本文是面向开发者的「功能实现进度 & 技术细节」说明，所有内容都已经在代码层落地，只是按领域分段记录，便于后续维护和迭代。

## 0. 用户路径 & 文档导航

- **入口（Library & Dashboard）**：选择/扫描 Vault → 在 Dashboard 中查看今日任务与历史统计，并可通过 Smart Queue 启动复习 Session。
- **复习过程（Review Player）**：在 NoteRenderer 中切换 Cloze / Blur 模式，配合右侧目录（TableOfContents）与底部 GradingBar 完成一张张卡片的评分。
- **内容编辑（EditMode & 挖空编写）**：在 Write 模式中编写 Markdown、管理 Frontmatter / Tags，并通过快捷键创建/维护 Cloze。
- **检索与跳转（GlobalSearch / TOC / Cloze 导航）**：全局按内容搜索卡片，或使用 Outline / Cloze Navigator 在单篇笔记内部跳转。
- **数据同步（增量同步 & 乐观 UI）**：元数据与 FSRS 状态通过 Supabase 增量拉取；具体协议见 `docs/DEVELOPER_GUIDE_FSRS_FLOW.md` 与 `docs/DESIGN_INCREMENTAL_AND_OPTIMISTIC.md`。

## 1. Library / Dashboard / Vault 功能实现进度

### 1.1 LibraryView：Vault 选择 + 文件分组

- **状态依赖**：从 `useAppStore` 订阅 `rootPath`、`files`、`fileMetadatas`、`vaults`、`syncMode`、`lastSyncAt` 等字段。
- **首次进入**：
  - `loadSettings()` 初始化主题、历史 Vault 等 UI 配置。
  - 未选择 `rootPath` 时展示 Welcome Screen，引导用户「Open Vault」或加载 Demo Vault。
- **扫描文件（本地优先）**：
  - 在 Tauri 环境下通过 `readDir` 深度遍历 `rootPath`，收集 `.md` 文件列表写入 `files`。
  - `DEMO_VAULT` 下返回内置 Demo 文件集合，避免真实文件依赖。
- **按 FSRS 状态分组文件**：
  - 通过 `fileMetadatas[file].cards` 汇总每个文件的卡片集合。
  - 按 **Overdue / Due Today / New Cards / Library** 四类归档：
    - 参考 `state`、`reps` 与 `due` 的组合规则（详见《状态管理设计.md》10.2 节）。
    - 「今天到期的新卡」同时计入 `New` 与 `Due Today`，与 Dashboard 的统计逻辑保持一致。
- **视图切换 & Tree 模式**：
  - `viewType` 本地 UI 状态控制 List / Grid / Tree 三种展示。
  - Tree 模式下复用 `FileTreeView`，并在路径层级顶部展示当前 Vault 根目录，提供清晰的上下文。

### 1.2 Dashboard：Smart Queue 总览与指标

- **嵌入方式**：Library 主内容区域通过 `DashboardLazy` 以 `mode="hero-only" | "insights-only" | "full"` 复用 Dashboard 布局。
- **数据来源**：
  - `files + fileMetadatas` 聚合得到 `dueItems / overdueItems / newItems / futureCounts` 等（见 `Dashboard.tsx` 中 `dashboardData` 计算）。
  - `reviewHistory` 通过 `loadReviewHistory()` 延迟加载最近 365 天记录。
- **核心交互**：
  - `ActionCenter` 展示今日任务数量，并提供：
    - 若已有 `queue` → 继续当前 Session（`handleResumeSession`：`loadNote` + `setViewMode('test')`）。
    - 否则从聚合结果中构造 `QueueItem[]`，调用 `setQueue` + `startSession()`，进入 Review Player。
  - `RecycleBin` 通过统一的 `restoreNote(noteId)` 与 VaultSlice 协作，完成云端软删恢复。
- **洞察面板（Insights）**：
  - 一系列图表组件（RetentionSimulator / ActivityGrid / WorkloadForecast / VaultHealth 等）直接消费 `dashboardData`，不触达具体 FSRS 算法，仅基于已计算好的统计值渲染 UI。

> 更底层的数据流（增量元数据拉取、FSRS 历史聚合）已经在《状态管理设计.md》和《DEVELOPER_GUIDE_FSRS_FLOW.md》详细展开，本文不再重复。

## 2. 目录功能实现进度（TableOfContents）

### 当前状态
- **模式覆盖**：Write（EditMode）、Cloze（ClozeMode）、Blur（BlurMode）三种模式下，右侧 Outline 均可正常列出标题并完成跳转 + 高亮。
- **容器统一**：三个模式共用同一个滚动容器 `note-scroll-container`，TOC 只对这一块内容做扫描与定位。

---

### 1. Header 收集逻辑（TableOfContents）

- **数据来源**：
  - 通过 `useAppStore` 读取 `currentNote`、`viewMode`。
  - `useEffect` 依赖 `[currentNote, viewMode]`，在笔记或模式变化时重新收集标题。

- **DOM 选择范围**：
  - 先用 `document.getElementById('note-scroll-container')` 拿到「学习视图」的滚动容器。
  - 如果容器不存在，直接清空 TOC（当前视图不需要 Outline）。

- **标题解析规则**：
  - 在容器内部执行 `querySelectorAll('h1[id], h2[id], h3[id], h4[id]')`：
    - 只关心带 `id` 的 h1~h4。
    - 忽略 `aria-hidden="true"` 里的标题（例如隐藏的预览层）。
    - 过滤掉无文本内容的 heading。
  - 将每个 heading 映射为：`{ id, text, level }`。

- **去抖 & 性能**：
  - 使用 `headersAreEqual(prev, next)` 做浅比较：长度 + 每个元素 `id/text/level` 全相等时不触发 `setHeaders`，避免无意义重渲染。
  - 使用 `MutationObserver` 监听 `note-scroll-container` 的 `childList + subtree` 变化：
    - 一旦 Cloze/Blur 内容重新渲染，或模式切换导致 DOM 更新，就重新跑一次 `collectHeaders`。
    - 内部用 `requestAnimationFrame` 合并多次 DOM 变动，减轻抖动。

- **调试信息**：
  - 每次收集完成会输出：
    - `console.debug('[TableOfContents] collectHeaders', { count, ids, levels })`
  - 实际排查时，只要看 `count` 是否为 0、`ids` 是否符合预期，就能快速判断问题出在「有没有 heading」还是「跳转逻辑」。

---

### 2. Scroll 跳转逻辑（scrollToHeader）

- **入口**：
  - 每一个 Outline 条目点击时调用 `scrollToHeader(header.id)`。

- **容器获取**：
  - 首先通过 `document.getElementById('note-scroll-container')` 拿到滚动容器：
    - 这是 Cloze / Blur 的外层 `motion.div`，包裹实际 Markdown 内容。
    - 如果容器不存在（例如当前是编辑模式、或布局还未挂载），直接打印 warning 并返回。

- **精确定位元素（解决重复 id / 隐藏层问题）**：
  - **第一步**：调用 `document.getElementById(id)` 获取文档中第一个同名元素。
  - **第二步**：如果该元素不在 `note-scroll-container` 中（`!container.contains(element)`）：
    - 说明命中了别处（典型场景：EditMode 预览中的同名 heading）。
    - 则在 `container.querySelectorAll('[id]')` 结果中，通过 `el.id === id` 再做一次精确匹配，只保留「真正位于学习视图容器里的」同名 heading。
  - **第三步**：若仍然找不到元素，则打印：
    - `console.warn('[TableOfContents] Scroll target not found for id "${id}"')` 并返回。
  - 调试时还会输出：
    - `console.debug('[TableOfContents] scrollToHeader', { id, hasContainer, foundInsideContainer })`，用于确认最终命中的元素是否在正确容器内。

- **滚动行为**：
  - 调用 `element.scrollIntoView({ behavior: 'smooth', block: 'start' })`：
    - 交给浏览器自动选择最近的滚动容器。
    - 配合 heading 上的 `scroll-mt-20`，自动避让顶部 sticky Header，避免标题被遮挡。

- **目标高亮（UX 反馈）**：
  - 点击后执行统一的「目标高亮」模式：
    1. 清除所有已有 `.toc-target-highlight`：
       - `document.querySelectorAll('.toc-target-highlight').forEach(el => el.classList.remove('toc-target-highlight'));`
    2. 为了反复点击同一个条目时动画能重新触发，强制一次 reflow：
       - `void element.offsetWidth;`
    3. 给目标 heading 加上 `.toc-target-highlight`：
       - 在 `src/index.css` 中定义了 `@keyframes toc-highlight`，使用 `color-mix(in srgb, var(--color-primary) ...)` 做柔和闪烁背景。
    4. 通过 `setTimeout` 在 1.5s 后移除该 class，避免永久污染 DOM。

---

### 3. 与各模式 / Markdown 的集成关系

### 3.1 NoteRenderer（布局与容器）

- Review 层结构：
  - 外层 `LayoutGroup` 中的第二层 `motion.div` 作为 Review 容器：
    - 赋值 `id="note-scroll-container"`。
    - 含 `overflow-y-auto`，是真正的滚动层。
    - 内部包裹 `ClozeModeLazy` 与 `BlurModeLazy`。
- TOC 的挂载：
  - `ThreeColumnLayout` 的 `right` 槽位在 `viewMode !== 'edit'` 时渲染 `<TableOfContents />`。
  - 因此 Outline 只在阅读 / 复习模式下出现，避免与编辑逻辑耦合。

### 3.2 MarkdownContent（标题 id 生成）

- 所有模式统一通过 `MarkdownContent` 渲染 Markdown：
  - 对 `h1~h4` 扩展组件，内部调用 `generateId(children)`：
    - 使用 `extractText` 提取纯文本内容（去掉图片、链接、cloze 等格式噪音）。
    - 将文本传给 `generateSlug`：
      - 先用 `cleanMarkdown` 清理 Markdown 语法。
      - 再按「字母数字 + 中文」保留规则构造 slug，其他字符替换为 `-`。
      - 相同标题会追加 `-1`, `-2` … 保证 `id` 唯一。
  - 每个 heading 上统一增加 `scroll-mt-20`，用于滚动定位时自动预留顶部空间。
  - 基于 `MarkdownSplitter.split(currentNote.content, tags)` 计算 `sectionCardCounts`：
    - 将整篇笔记拆分为带有 `sectionPath` 的内容块；每块统计其中的 `clozeIds` 数量。
    - 按标题路径将数量累加到 `sectionCardCounts[title]`，在 Outline 每一行右侧渲染该节下的卡片总数，帮助用户快速判断「这一节有多少练习点」。

### 3.3 各模式具体行为

- **EditMode**：
  - 右侧预览同样使用 `MarkdownContent`，会生成一套带 id 的 heading。
  - 但 TOC 的 header 收集与跳转逻辑都限定在 `note-scroll-container` 内，因此不会误命中 Edit 预览层的 heading。

- **ClozeMode**：
  - 使用 `currentNote.renderableContent` 渲染 Markdown，标题体系与 Edit 预览保持完全一致。
  - Cloze 链接（`#cloze-xxx`）通过自定义 `a` 组件渲染为可交互的填空 chip，与标题逻辑互不干扰。

- **BlurMode**：
  - 先用 `cleanContent` 去掉高亮与 cloze 语法，再交给 `MarkdownContent` 渲染。
  - 仍然生成同样的 heading id，因此 TOC 在 Blur 模式下也能正确跳转到对应标题。

---

### 4. 鲁棒性与后续可扩展性

- **容器解耦**：
  - 通过固定的 `id="note-scroll-container"` 把「布局 / 动画」与「TOC 逻辑」隔离开，后续调整动画或增加模式时，只要保持这一层不变，TOC 就能继续工作。

- **DOM 优先而非字符串猜测**：
  - TOC 的数据来源完全基于真实 DOM（已渲染出来的 h1~h4），而不是重新解析 Markdown 文本，避免重复实现解析器、减少错位概率。

- **重复 id 与隐藏节点处理**：
  - 利用 `container.contains(element)` + 容器内部二次匹配，确保只滚到「用户实际看到的那份」 heading。
  - 对 `aria-hidden` 的 heading 直接忽略，避免动画/过渡层干扰。

- **可观测性**：
  - `collectHeaders` 与 `scrollToHeader` 均输出详细日志，实际排查时只需观察：
    - 收集到的 `ids` 是否正确；
    - `foundInsideContainer` 是否为 `true`；
    - 即可快速定位问题落在「没有渲染出标题」还是「跳转命中了错误元素」。

---

## 3. 挖空功能实现进度

## 1. 预览与编辑的交互协同（Preview-Editor Interaction）
- **架构模式**：
  - Preview 负责**渲染与事件捕获**：`MarkdownContent` 渲染 Cloze Chip，捕获点击与右键事件，传递 `id` 和 `occurrenceIndex`。
  - Editor 负责**源码定位与光标控制**：`EditMode` 接收事件后，利用 `ClozeUtils` 的正则扫描能力，将视觉上的 Chip 映射回源码中精准的字符偏移量（`selectionStart/End`）。

- **精准定位与滚动（Scrolling & Highlighting）**：
  - **坐标计算**：使用 `getCaretCoordinates`（隐形镜像 DIV 方案）计算光标在 `<textarea>` 中的像素坐标，解决了 Textarea 自动换行导致行号计算不准的问题。
  - **双向同步**：
    - 编辑器滚动：自动将源码位置滚动至视口约 30% 高度处，确保上下文可见。
    - 预览滚动：同时将对应的 Preview Element 滚动至视口中心。
  - **视觉反馈**：
    - 摒弃了扩散光圈，改用 **Border-Only Pulse** 动画（CSS `@keyframes cloze-flash`）。
    - 通过 `box-shadow` + `border-color` 的微弱缩放（1.02x）与颜色脉冲，提供清晰但不干扰阅读的视觉确认。

- **Cloze Navigator（挖空导航条）**：
  - **时间轴设计**：将所有挖空 ID 展示为水平滚动的 Timeline Strip，提供全局概览。
  - **数量透视**：在每个 ID 胶囊上通过内嵌 Badge（如 `c1 [3]`）显式展示该 ID 的复用次数，便于识别分组挖空。

- **数据完整性（Data Integrity）**：
  - **自动修复**：提供 `normalizeClozeIds`（重排 ID）和 `cleanInvalidClozes`（清洗格式）工具。
  - **实时检测**：在 Toolbar 上实时统计 `unclosed`（未闭合）、`malformed`（格式错误）、`dangling`（多余闭合）等异常状态。

 ---

## 2. Cloze 学习 / 复习模式（ClozeMode）

- **数据管线与解析结果**：
  - `parser.parseNote(rawMarkdown)` 负责抽取所有挖空信息，返回 `ParsedNote`：
    - `clozes: ClozeItem[]`，每个元素包含 `id`、`answer`、`hint` 等字段。
    - `renderableContent` 中，普通挖空被替换为 `[Answer](#cloze-{id}-{hint?})` 的链接形式；整块公式挖空转换为 ```math-cloze-{id}``` fenced code block。
  - Cloze 学习模式直接消费 `currentNote.renderableContent` 与 `currentNote.clozes`，不再重复解析原始 Markdown。

- **按出现次数区分的唯一 key（id + occurrenceIndex）**：
  - 为了解决「同一个 id 多次出现」的问题，ClozeMode 在渲染阶段为每个挖空构造唯一 key：
    - 使用 `clozeCountsRef: Record<number, number>` 记录当前渲染过程中每个 `id` 已出现的次数。
    - 每次遇到 `id`，先读出当前计数 `occurrenceIndex`，随后自增：`const key = `${id}-${occurrenceIndex}``。
    - 将该 key 同时用于：
      - React 内部状态字典 `revealed[key]`；
      - DOM 属性 `data-cloze-key={key}`，用于后续滚动与高亮定位。

- **显隐状态管理（per-occurrence revealed state）**：
  - `revealed: Record<string, boolean>` 以 `"id-occurrenceIndex"` 为键，单独记录每个挖空 chip 是否已揭示。
  - `allClozeKeys: string[]` 通过 `useMemo` 从 `currentNote.clozes` 推导，代表当前笔记中所有 occurrence 的完整 key 列表，是 Space 三态逻辑的基础。
  - 单个挖空点击时调用 `toggleReveal(key)`：
    - 若 `revealed[key]` 为假，则将其置为 `true`，不影响任何其他 key。
    - 根据当前模式决定是否触发彩带动画（自由模式 / 当前 cloze 目标）。

- **自由学习模式（预览模式）下的三态 Space 行为**：
  - 当 `currentClozeIndex === null` 时，视为「自由学习 / 预览模式」：
    - 所有挖空都视为 `isTarget = true`，可点击且动画一致。
    - `isRevealed = !!revealed[key]`，完全按 per-occurrence 状态控制显隐。
  - Space 键通过 `useKeyboardShortcuts` 统一 dispatch `shortcut-reveal` 自定义事件（过滤 `e.repeat` 防止长按连发）。
  - ClozeMode 监听该事件后调用 `toggleAll()`：
    - 计算 `allRevealedNow = allClozeKeys.every(key => revealed[key])`。
    - 若全部关闭或部分打开 → 将 `allClozeKeys` 全部标记为 `true`（全部打开）。
    - 若全部已打开 → 重置为 `{}`（全部关闭）。
  - 标题区域同时提供 `Show All / Hide All` 按钮，直接复用同一套 `isAllRevealed` 与 `toggleAll` 逻辑。

- **队列复习模式下的特殊逻辑（currentClozeIndex !== null）**：
  - 通过 `currentClozeIndex` 区分当前复习的 cloze id：
    - 当前 id：`isTarget = (id === currentClozeIndex)`，默认隐藏，由 `revealed[key]` 控制显隐。
    - 非当前 id：`isTarget = false`，在 UI 上作为上下文存在。
  - 显隐行为：
    - 当前 id：
      - `isRevealed = !!revealed[key]`，可以通过 Space 或单击逐个/全部开启。
      - 点击时仅修改当前 occurrence 的 `revealed[key]`，不会联动同一 id 的其他 occurrence。
    - 非当前 id：
      - 在队列模式下强制 `isRevealed = true`，始终展开，作为「锁定上下文」，不参与遮挡练习。
      - 点击被禁用（`canToggle = currentClozeIndex === null || isTarget`），也不会被 Space 改变状态。
  - Space 键的三态在队列模式中只作用于当前 id：
    - `targetKeys = allClozeKeys.filter(key => parseInt(key.split('-')[0], 10) === currentClozeIndex)`。
    - 若 `targetKeys` 全部已揭示 → 仅删除这些 key 的 `revealed` 记录，其他 id 保持不变。
    - 若存在未揭示 → 将所有 `targetKeys` 置为 `true`，一键展开当前 cloze 的所有 occurrence。

- **自动引导到下一处挖空（队列模式专属）**：
  - 在队列模式中，`toggleReveal(key)` 成功揭示当前 occurrence 后，会调用 `focusNextOccurrence(key)`：
    - 从 `allClozeKeys` 中按顺序筛出所有当前 id 的 `targetKeys`。
    - 在其中找到 `currentKey` 的索引，定位下一个 `nextKey`，并查找对应 DOM 元素：`[data-cloze-key="nextKey"]`。
    - 若该元素不在视口中部附近，则使用 `scrollIntoView({ behavior: 'smooth', block: 'center' })` 平滑滚动。
    - 为该元素临时加上 `.toc-target-highlight` class，复用 TOC 高亮动画，1.5 秒后自动移除，形成「下一题在这里」的视觉指引。

- **动画与微交互（Framer Motion + 主题一致性）**：
  - 文本挖空 chip 使用 `motion.span` 渲染，基于当前显隐与是否为上下文决定动画状态：
    - 上下文（非当前 id）：`opacity ≈ 0.9`，轻微背景，始终可见但偏低对比度。
    - 隐藏状态：略微缩小（`scale: 0.97`），文字透明，仅保留底部边框与占位宽度，可选显示 Hint 文本。
    - 已揭示：恢复为正常大小与不透明度，使用 `success` 色系强调「已答出」。
  - 交互反馈：
    - `whileHover={{ scale: 1.03 }}`、`whileTap={{ scale: 0.97 }}` 提供按钮式按压反馈，统一使用弹簧物理参数（`stiffness / damping / mass`）与其他模式保持一致。
  - 数学挖空 `MathClozeBlock` 同样接受 `isRevealed` 与 `isInteractive`：
    - 队列模式下仅当前 id 的 Math Cloze 可点击，其余用 `opacity-60` 作为静态上下文显示。

- **当前实现进度小结（Cloze 学习 / 复习）**：
  - 已完成：
    - 解析 → 渲染 → per-occurrence 状态 的完整数据流闭环。
    - 自由模式与队列模式下统一的 Space 三态逻辑，并在队列模式中仅作用于当前 cloze id。
    - 单个挖空点击只影响当前 occurrence，避免「同 id 一起打开」的困惑。
    - 队列模式下的上下文锁定（非当前 id 始终展开且不可交互）。
    - 基于 `.toc-target-highlight` 的「下一处挖空」滚动与高亮引导。
    - 与整体 Review 动效体系一致的 Framer Motion 微交互（hover / tap / reveal）。
  - 后续可选优化方向：
    - 针对「全部展开 / 全部收起」动作设计更丰富的群体动效（例如按文档顺序渐进式展开）。
    - 为当前 cloze id 增加更明显的「当前题号标记」动画，与 GradingBar 状态进一步联动。

## 4. 编辑模式功能实现

 ## 1. 元数据编辑器（Metadata Editor）

- **独立组件化**：将 Frontmatter 编辑从源码区剥离，封装为独立的 `MetadataEditor` 组件，位于编辑器顶部，只通过 `props` 接收：
  - `content: string`：整篇 Markdown 源文。
  - `onChange(newContent: string)`：写回更新后的完整文档.
- **Frontmatter 解析与回写流程**：
  - 初始挂载以及每次 `content` / `isOpen` 变化时，通过 `gray-matter` 解析当前文档：
    - `const { data } = matter(content)`.
    - 将 `data.tags` 归一化为 `string[]`：
      - 若本身是数组则直接使用。
      - 若是逗号分隔字符串，则按 `,` 切分并 `trim()` 再过滤空项.
  - 组件内部只维护 `tags: string[]` 与 `inputValue: string`，不在每次输入时直接改写 `content`.
  - `commitToContent(newTags)`：
    - 重新 `matter(content)` 提取 `file.data` 与 `file.content`.
    - 合并为 `newData = { ...file.data, tags: newTags }`，确保其他 Frontmatter 字段完全保留.
    - 使用 `matter.stringify(file.content, newData)` 生成新的完整 Markdown 字符串，统一通过 `onChange` 写回.
- **交互优化（Tag Chips System）**：
  - **连续输入 / 自动分词**：
    - 在输入框 `onKeyDown` 中拦截 `Enter` 与逗号 `,`：
      - `e.preventDefault()` 阻止提交表单或输入逗号.
      - 对 `inputValue` 做 `trim()`，若非空且不在现有 `tags` 中，则追加到 `tags` 并调用 `commitToContent`.
      - 提交后自动清空输入框，支持「连续输入 → 回车 → 连续输入」的流畅体验.
  - **键盘友好（Backspace 语义）**：
    - 当输入框为空且用户按下 `Backspace` 时，删除 `tags` 数组的最后一个元素并立刻 `commitToContent`，符合现代 Tag Input 的交互习惯.
  - **Blur 时的惰性提交**：
    - 在 `onBlur` 里，如果输入框中仍有非空内容，则按与 `Enter` 相同的逻辑自动转为 Tag 提交，避免用户切换焦点丢失未确认的输入.
  - **Chip 删除操作**：
    - 每个 Tag Chip 上挂载 `removeTag(tag)`，点击即可将其从 `tags` 数组中过滤掉并再次 `commitToContent`，同时保持 UI 动画（淡入/缩放）的一致性.
- **非阻塞更新策略**：
  - Tag 编辑时仅更新本地 `tags` 状态，只有在**明确提交动作**（Enter/`,`/Backspace 删除/Blur/点击 Chip 的关闭按钮）发生时才整体回写到 `content`.
  - 避免了「每输入一个字符就重建整篇 Markdown」的问题，从根本上解决了性能抖动和焦点丢失.
- **UI 设计（Collapsible Header）**：
  - 顶部使用一行 `Properties` 标题 + Chevron 图标的折叠头部，状态由 `isOpen` 控制.
  - 折叠时仅保留一条细边框和半透明背景，作为源码编辑区与属性区的视觉分隔.
  - 展开后显示 Tag Chips 胶囊区，采用与主 Toolbar 一致的 Glassmorphism 风格（半透明背景 + 轻微边框 + 小尺寸 Badge），在窄高布局下占用最小垂直空间。
## 2. 编辑体验增强

- **智能插入（Smart Insertion）实现**:
  - 所有 Markdown 包裹操作统一通过工具函数 `insertText(before, after)` 实现，供顶部 Toolbar 按钮与键盘快捷键复用.
  - 在执行插入前，对当前选区文本进行「首尾空白修剪（Smart Trim）」:
    - 使用正则分别匹配选区前导与后缀空白长度，若选区中存在非空内容，则调整 `selectionStart` / `selectionEnd` 到实际文字边界，只包裹中间的有效文本.
    - 即用户选中 `" foo "` 后点击 Bold，最终变成 `**foo**` 而不是 `** foo **`.
  - 插入过程优先调用浏览器原生 `document.execCommand('insertText', false, newText)`:
    - 能够与原生 Undo/Redo 栈无缝集成，保持「Ctrl+Z / Ctrl+Y」的自然行为.
    - 若 `execCommand` 返回 `false`（某些环境不支持），则回退为手动拼接字符串并 `setContent`.
  - 插入完成后通过 `setTimeout(0)` 再次将光标选区设置到包裹文本的内部区域（`before` 与 `after` 之间），便于用户立即继续输入或再次格式化，而不是把光标抛到行尾。
- **Cloze 插入逻辑**:
  - 统一由 `insertCloze(sameId = false)` 负责，直接基于 `textarea.value` 计算，不依赖滞后的 React 状态，避免竞态.
  - **ID 计算**:
    - 调用 `ClozeUtils.getMaxClozeNumber(full)` 扫描全文，得到当前最大 `cN`.
    - `sameId = false` 时，一律使用 `maxId + 1` 作为新卡片 ID，保证 ID 单调递增.
    - `sameId = true` 时:
      - 优先通过 `ClozeUtils.findPrecedingClozeId(full, cursorIndex)` 找到光标前最近的 Cloze ID，作为「同卡片」的目标.
      - 若找不到，则退回 `maxId` 或 `maxId + 1`，保证在无历史 cloze 时依旧能正常插入.
  - **选区与包裹**:
    - 复用 Smart Trim 逻辑，对选中文本剔除首尾空白，仅对中间部分外包 `{{cN::...}}`.
    - 若当前无任何选中文本，则使用占位符 `'...'` 生成 `{{cN::...}}`，并在后续自动选中该占位符，提示用户直接覆写.
  - **状态与焦点处理**:
    - 插入成功后立即更新 `content` 与 `targetClozeId`，驱动 Cloze Navigator 高亮当前 ID.
    - 使用延迟回调（`setTimeout`）将光标选中到 cloze answer 区间（`answerStart ~ answerEnd`），兼顾 Undo 栈与连续输入体验.
- **快捷键体系**:
  - 所有快捷键集中在 `textarea` 的 `onKeyDown` 中处理，通过组合判断 `ctrlKey` / `metaKey` / `shiftKey` / `altKey` 区分不同操作，并统一 `e.preventDefault()` 屏蔽浏览器默认行为（如浏览器级保存、查找等).
  - **标准格式**:
    - `Ctrl/Cmd + B` → 调用 `insertText('**', '**')` 实现加粗.
    - `Ctrl/Cmd + I` → 调用 `insertText('*', '*')` 实现斜体.
  - **Anki 兼容 Cloze 操作**:
    - `Ctrl/Cmd + Shift + C` → 调用 `insertCloze(false)`，创建新 ID 的 Cloze（`{{cN::...}}`），与 Anki 默认行为一致.
    - `Ctrl/Cmd + Alt + C` → 调用 `insertCloze(true)`，在「最近使用或最大」ID 上追加新的 Cloze 片段（同一张卡的多处遮盖).
  - **维护操作**:
    - `Ctrl/Cmd + Shift + X` → 调用 `handleClearCloze()`:
      - 若存在选区，则调用 `ClozeUtils.removeClozesInRange` 只对选区内的 Cloze 进行清除，避免整篇字符串重写.
      - 若无选区，则通过 `ClozeUtils.unclozeAt(full, cursorIndex)` 对光标所在的单个 Cloze 进行「还原文本」，并将光标移动到恢复后的文本末尾.
  - **导航与存盘**:
    - `Alt + ↑/↓` → 调用 `jumpToSiblingCloze('prev' | 'next')`:
      - 使用正则 `{{c(\d+)::` 遍历全文，按物理顺序定位上一个/下一个 Cloze.
      - 再通过 `getCaretCoordinates` 精确计算像素偏移，将目标 Cloze 滚动到编辑区顶部约 30% 的位置，保持上下文可见.
    - `Ctrl/Cmd + S` → 调用 `handleSave()`:
      - 执行「本地文件写入 → 内存缓存更新（`contentCache`）→ 数据服务同步（Supabase）」的流水线，并通过 `lastSelfSaveAtRef` 与 `useFileWatcher` 协同，屏蔽由自己触发的文件系统事件，避免重复加载。
## 5. Blur 模式功能实现

## 1. 数据来源与实时刷新

- **状态来源**:
  - 通过 `useAppStore`（配合 `useShallow`）只订阅 `currentNote`、`currentFilepath` 与 `loadNote`，避免无关状态变化导致重复渲染.
  - 若当前没有 `currentNote`，组件直接返回 `null`，保证 BlurMode 只在有选中笔记时工作.
- **文件变更监听**:
  - 使用 `useFileWatcher(currentFilepath, callback)` 监听当前 Markdown 文件:
    - 一旦检测到文件内容变更，自动调用 `loadNote(currentFilepath)` 重新加载笔记.
    - 与 EditMode 的监听策略保持一致，保证在外部编辑器修改文件时，Blur 模式视图能自动刷新。
## 2. 内容清洗管线（cleanContent）

- **高亮语法剥离**:
  - 使用正则 `/(==)(.*?)(==)/g`，将 `==高亮内容==` 替换为纯文本部分，只保留语义内容，不保留高亮标记本身.
- **Cloze 语法剥离**:
  - 使用正则 `/{{c\d+::([\s\S]*?)(?:::(.*?))?}}/g` 将 Cloze 语法统一还原为答案文本:
    - `{{c1::answer}}` 或 `{{c1::answer::hint}}` → `answer`.
  - 这样 Blur 模式看到的是「已还原文本」，而不是挖空标记，方便统一做模糊处理.
- **与 MarkdownContent 的集成**:
  - 将清洗后的字符串传给 `MarkdownContent` 的 `content` 属性，并保持 `disableIds={false}`:
    - 继续为 `h1~h4` 生成稳定的 `id`，与 Cloze / Edit 预览保持一致.
    - 确保目录（TableOfContents）在 Blur 模式下仍可正常跳转到对应标题.
## 3. 布局与闪光灯容器

- **自适应边距与沉浸模式**:
  - 根容器 `div` 采用 `w-full min-h-full flex flex-col select-none`，并根据 `immersive` 参数切换不同的内边距:
    - 普通模式：`px-8 py-8`，适合带 Outline / 控件的常规布局.
    - 沉浸模式：`px-12 py-4`，在大屏幕上提供更居中的阅读体验.
- **标题区与过渡动画**:
  - 标题行采用 `flex justify-between items-center`，并根据 `immersive` 切换字号与下边距:
    - 普通模式：大号标题（`text-4xl`）+ 下边框分隔（`border-b`），强调结构感.
    - 沉浸模式：较小字号（`text-2xl`），整体透明度默认偏低，鼠标悬停时通过 `hover:opacity-100` 渐显，减少干扰.
- **闪光灯容器职责划分**:
  - Blur 模式中的「Flashlight Container」只负责布局与包裹内容:
    - 注释说明：模糊与光斑效果实际在外层 `note-scroll-container` 级别处理.
    - 内部只渲染一个 `prose prose-lg max-w-none` 的 Markdown 区域，确保文本排版与其他模式保持一致.

## 4. Hints 与操作提示

- **Hints 提示区**:
  - 从 `currentNote.hints` 读取字符串数组，在非沉浸模式下渲染为顶部黄色提示块:
    - 使用 `bg-warning/10 + border-l-4 border-warning` 的样式强调其为「辅助提示」.
    - 逐条以无序列表展示，适合写「复习要点」「注意事项」等辅助信息.

- **模式操作提示（ModeActionHint）**:
  - 在标题右侧使用 `ModeActionHint` 组件展示操作说明:
    - 文案为 `Hold SPACE to Peek`，提示用户按住空格键可以临时「窥视」被模糊的内容.
    - 仅在非沉浸模式下显示，避免在专注阅读场景中出现多余 UI.

---

## 6. 复习会话与评分系统实现进度（Review Session & Grading）

## 1. GradingBar 底部评分 Dock（UI & 交互）

- **布局形态（不遮挡正文）**:
  - 在 Review / Test 模式下使用 `fixed bottom-8 left-0 right-0 flex justify-center z-50` 将评分条悬浮于视口底部.
  - 外层容器使用 `pointer-events-none`，仅内部胶囊使用 `pointer-events-auto`，保证不会误挡正文区域的滚动与点击.
  - 胶囊整体采用 `bg-base-100/90 + backdrop-blur-md + border + shadow-2xl + rounded-full` 的 Glassmorphism 风格，与 Library / Header 的视觉体系保持一致.

- **评分选项与键盘映射**:
  - 使用 `GradeOption[]` 固定四档评分：
    - Again（1）：完全想不起来.
    - Hard（2）：勉强回忆，需要较大努力.
    - Good（3）：回忆基本顺利.
    - Easy（4）：非常轻松，无需思考.
  - 每个按钮在 `tooltip` 中附带说明文案，并在右上角使用小圆角 Badge 显式展示快捷键（1 / 2 / 3 / 4）.
  - 通过 `window.addEventListener('keydown')` 监听键盘：
    - 若当前不在 grading 中，且没有 Ctrl/Alt/Meta/Shift 修饰键，则按下 `1~4` 直接调用 `handleRate(rating)`.

- **动效与加载状态**:
  - 正常状态下按钮使用 `hover:scale-105` / `active:scale-95` 提供轻微的按压反馈，与其它控制组件保持统一的物理感受.
  - `isGrading === true` 时：
    - 按钮禁用，并显示一层半透明覆盖 + `loading-spinner`，防止重复提交评分.
    - 布局保持占位不变，避免 UI 抖动影响记忆流.

## 2. 评分前的 FSRS 间隔预览（Scheduling Preview）

- **数据来源**:
  - 通过 `useAppStore` 读取 `getSchedulingPreview`，在 `currentMetadata` 变化时触发预览计算：
    - `useEffect(() => { if (currentMetadata) setPreviews(getSchedulingPreview()); }, [currentMetadata, getSchedulingPreview])`.
  - `previews` 本地状态类型为 `Record<number, { interval: string }>`，以评分值（1~4）为 key 存储各自的下次间隔标签.

- **核心算法（SessionSlice.getSchedulingPreview）**:
  - 从 `currentMetadata.cards[currentClozeIndex]` 读取当前 cloze 所对应的 FSRS `Card` 状态；若不存在则使用 `createEmptyCard()` 视为新卡.
  - 读取当前 Vault 的 FSRS 配置：`const params = currentVault?.config?.fsrsParams;`.
  - 使用 `fsrs(params)` 创建 FSRS 实例 `f`，并调用 `f.repeat(currentCard, now)` 获得 4 档评分下的调度结果 `scheduling_cards[1..4]`.
  - 对每个评分记录：
    - 将 `record.card.due` 转成 `Date`.
    - 使用 `formatDistanceToNow(dueDate)` 生成人类可读的相对时间（如 `in 3 days`）。
    - 通过字符串替换压缩为紧凑形式：
      - `minutes / minute -> m`，`hours / hour -> h`，`days / day -> d`，`months / month -> mo`，`years / year -> y`.
      - `less than a minute -> now`，去掉前缀 `about `，形成 `1m / 6m / 2d / 4d` 风格的标签.
    - 最终返回 `Record<number, { due: Date; interval: string }>`，供 GradingBar 展示.

- **UI 呈现方式**:
  - GradingBar 为每个评分按钮垂直排列两行信息：
    - 上行：`Again / Hard / Good / Easy` 文本标签，强调语义含义.
    - 下行：等宽字体的 `interval` 标签（例如 `1m`、`6m`、`2d`、`4d`），直接援引 FSRS 计算结果.
  - 若预览计算失败或当前卡片状态不完整，则显示 `-` 作为占位，避免界面闪烁.

## 3. Vault 级 FSRS 参数与 saveReview 流程

- **Vault 级参数接入**:
  - 在 SessionSlice 中，无论是预览函数 `getSchedulingPreview` 还是真正提交评分的 `saveReview`，都统一从 `currentVault.config.fsrsParams` 读取参数并传给 `fsrs(params)`.
  - 这意味着不同 Vault 可以配置不同的学习节奏：
    - 例如「词汇 Vault」使用更短的首轮间隔（更频繁复习）。
    - 「理论知识 Vault」可以使用更保守的间隔，降低每日复习负担.
  - GradingBar 上展示的间隔预览会自动随 Vault 配置变化，无需前端额外判断.

- **评分提交逻辑（saveReview）**:
  - 前置校验：
    - 必须存在 `currentFilepath`、`currentMetadata`，且 `currentClozeIndex !== null`.
    - 若当前 `isGrading` 为真，或 `sessionIndex >= queue.length`，则给出 toast 提示并中止本次评分.
  - 调度计算：
    - 使用与预览相同的 `params` 创建 FSRS 实例：`const f = fsrs(params)`.
    - 调用 `f.repeat(currentCard, new Date())` 获取 `scheduling_cards`，并从中取出本次评分对应的 `record = scheduling_cards[rating]`.
    - 若未能取到对应记录，则认为评分失败并提示错误.
  - 即时反馈：
    - 依据评分生成 `ratingLabel`（Again / Hard / Good / Easy）。
    - 将 `record.card.due` 转为相对时间字符串（如 `in 2 days`），组成 `next ...` 提示.
    - 可选附带 `stability x.xx` 信息，最终拼成 `Again • next in 10 minutes • stability 1.23` 形式的反馈 toast.
  - 状态与后端更新：
    - 使用 `noteId = currentMetadata.noteId || currentFilepath` 作为后端主键：
      - SupabaseAdapter：调用 RPC `submit_review`，原子性更新 `cards` 表中该 cloze 的 FSRS 字段，并在 `review_logs` 表写入一条对应日志（包含 grade/state/stability/difficulty 等）。
      - MockAdapter：在浏览器 localStorage 中更新该 note 对应 entry 下的 `cards[clozeIndex]`，并往 `history` 数组追加一条 `ReviewLog`.
    - 同时在本地 Store 中构造新的 `NoteMetadata`：
      - 覆盖 `currentMetadata.cards[currentClozeIndex] = record.card`.
      - 更新 `lastReviews[currentClozeIndex] = record.log`，供未来 Dashboard / History 视图使用.
    - 通过 `set` 更新 `currentMetadata` 和 `fileMetadatas[currentFilepath]`，保证当前视图与全局索引保持一致.
  - 队列推进：
    - 若当前存在 Smart Queue：
      - 计算 `nextIndex = sessionIndex + 1`，若未越界则更新 `sessionIndex` 并调用 `loadNote(nextItem.filepath, nextItem.clozeIndex)` 加载下一张卡.
      - 若已经是队列最后一张，则将 `viewMode` 设为 `summary`，并弹出 `Session Complete!` 的成功提示.
    - 若当前不在 Session 中（例如从 Library 单独打开某条 Note 手动打分），则只弹出 `Review saved` 提示，不变更视图.

## 4. Smart Queue 与「到期卡片」协同

- **到期卡片拉取（fetchDueCards）**:
  - 通过 `dataService.getDueCards(limit, vaultId?)` 统一封装不同后端：
    - Supabase：
      - 当存在 `currentVault` 时，在查询中附加 `notes.vault_id = currentVault.id` 条件，只拉取**当前 Vault** 下、`due <= now` 且 `is_suspended = false` 的未删除卡片，并联结 `notes` 过滤掉已被软删除的笔记.
      - 若当前没有选中 Vault，则保持向后兼容，不加 `vault_id` 过滤，行为与旧版本一致（按用户维度跨所有 Vault 拉取到期卡片）。
      - 结果按 `due` 升序排序，限制返回条数 `limit`，并将 `note.relative_path + vault_id` 解析为绝对文件路径.
    - Mock：
      - 在本地 JSON 结构中遍历每个 note 的 `cards` 字典，选出 `card.due <= now` 的项，并按 `due` 升序排序.
  - Store 中将结果保存为 `queue: QueueItem[]`，Dashboard 的 `SmartQueue` 组件会展示「今日到期卡片数量」，并提供「Start Session」按钮进入正式复习.
  - **SQL 与索引层优化**：
    - 在 `notes` 表新增复合索引 `idx_notes_vault_id_is_deleted (vault_id, is_deleted)`，加速带 Vault 过滤且排除软删除笔记的查询.
    - 在 `cards` 表新增部分索引 `idx_cards_due_active ON cards(due) WHERE is_deleted = false AND is_suspended = false`，专门服务 Smart Queue 的 `due <= now` 查询，避免扫描无效卡片。

- **Session 生命周期与统计**:
  - `startSession`：
    - 以当前 `queue` 初始化 `sessionTotal`、`sessionIndex`、`sessionStats`（包括每个评分档位的计数）。
    - 自动加载第一张卡并切换视图到 `viewMode: 'test'`，形成从 Dashboard 进入 Review Player 的连贯体验.
  - `saveReview` 在每次评分成功后：
    - 递增 `sessionStats.reviewedCount` 与对应评分的计数（`ratings[rating]++`）。
    - 根据队列位置切换到下一张或结束 Session.
  - Session 结束后进入 `summary` 视图，为后续实现「本次复习总结」留出扩展空间（如展示各档评分分布、平均稳定度变化等）。

## 5. 全局搜索与 Vault 过滤（GlobalSearch & searchCards）

- **数据流程**：
  - Dashboard 的 `GlobalSearch` 组件通过 `useAppStore` 读取 `searchCards`，只关心查询结果列表，不直接触达具体后端实现。
  - Store 中的 `searchCards(query)` 会从 `AppState` 读取 `currentVault`，构造 `vaultId = currentVault?.id`，并统一调用 `dataService.searchCards(query, vaultId)`。

- **前端交互行为（GlobalSearch 组件）**：
  - 输入框内容通过本地 `query` 状态管理，并经 `useDebounce(query, 300)` 去抖后触发实际搜索，避免每击键都打 Supabase 查询。
  - 结果面板在 `query` 非空或存在 `results` 时展示，并通过外层 `searchRef` + `mousedown` 监听点击空白处自动收起。
  - 每条结果点击后：
    - 从返回记录中推导 `filepath` 与 `clozeIndex`，调用 `loadNote(filepath, clozeIndex)`。
    - 依据顶部 Study / Edit 切换按钮的 `openMode` 决定进入 `viewMode: 'test'` 还是 `viewMode: 'edit'`。
    - 清空查询并关闭下拉，形成「搜索 → 直接打开并进入学习/编辑」的一步跳转体验。

- **Supabase 实现细节**：
  - `SupabaseAdapter.searchCards(query, vaultId?)`：
    - 以 `cards` 为主表，使用 Supabase 的关系查询语法联结 `notes`：
      - `select "*, notes(relative_path, title, is_deleted, vault_id)"`。
    - `where` 条件：
      - 使用 `ilike('content_raw', "%${query}%")` 在原始内容上做全文模糊匹配。
      - 过滤掉软删除卡片与笔记：`is_deleted = false AND notes.is_deleted = false`。
      - 当传入 `vaultId` 时，额外附加 `notes.vault_id = vaultId` 条件，实现**当前 Vault 作用域内**的搜索；未传入时保持向后兼容，跨用户所有 Vault 搜索。
    - 返回结果中继续使用 Vault 根路径缓存（`getVaultRootPath` + `vaultRootMap`）将 `notes.relative_path` 解析为绝对文件路径，供 UI 直接跳转。

- **Mock 实现与兼容性**：
  - `MockAdapter.searchCards(query, vaultId?)` 目前仍然返回空数组，仅作为接口占位：
    - 保证在本地 Mock 模式下调用不会报错，但不做真正的内容搜索。
    - UI 层可以根据 `syncMode === 'mock'` 决定是否提示「本地模式暂不支持全文搜索」。

- **索引支撑（与既有设计衔接）**：
  - 继续复用 `cards` 上的 trigram GIN 索引：`idx_cards_content_search ON public.cards USING GIN(content_raw gin_trgm_ops)`，为 `ilike` / 模糊搜索提供基础性能保证。
  - 配合前述 `idx_notes_vault_id_is_deleted` 复合索引，使得 `vaultId + is_deleted` 条件能够在 Notes 侧高效过滤。

---

## 7. 动画与沉浸体验（Animations & Immersive UX）

本节汇总目前已经实现的几类核心动效与沉浸体验模式，作为后续统一风格与扩展的参考基线。

### 7.1 Library 进入与视图切换

- **Welcome → Library 过渡**（`LibraryView`）：
  - 使用 `AnimatePresence mode="wait"` 管理「Welcome Screen / Main Library」两个场景：
    - Welcome：`initial { opacity: 0, scale: 0.95 }` → `animate { opacity: 1, scale: 1 }`，退出时 `exit { opacity: 0, scale: 1.05, filter: 'blur(10px)' }`，营造「向内容深潜」的视觉感受。
    - Library 主内容：`initial { opacity: 0, y: 20, scale: 0.98 }` → `animate { opacity: 1, y: 0, scale: 1 }`，离场时反向轻推（`y: -20`），整体节奏柔和。
  - 背景使用两层缓慢运动的彩色 Blob（`motion.div` + `scale/rotate` 循环动画）营造「神经网络」氛围，与 Review Player 的动效风格相呼应。
- **Dashboard Tab 切换**：
  - Library 内部的 Focus / Insights 切换、以及 Dashboard 内部的部分视图，都使用带 `layoutId` 的滑动胶囊（pill）背景：
    - `motion.div` 携带 `layoutId="dashboard-tab-pill"`，在不同按钮间切换时复用同一布局 ID，形成平滑滑块效果。
    - 物理参数：`transition={{ type: 'spring', bounce: 0.2, duration: 0.6 }}`，与 NoteRenderer 顶部模式切换保持一致。

### 7.2 NoteRenderer 双层布局与模式切换

- **LayoutGroup 双层架构**：
  - 使用 `LayoutGroup` 包裹 Editor 与 Review 两层：
    - Layer 1（Editor）：`EditModeLazy` 永久挂载在 `motion.div` 中，通过 `x / opacity / scale / zIndex` 控制显隐：
      - 编辑模式：`x = 0, opacity = 1, scale = 1, zIndex = 10`。
      - 复习模式：`x = '-20%' , opacity = 0, scale ≈ 0.98, zIndex = 1`，形成轻微「退到侧面」的视差感。
      - 不可见时将 `pointerEvents = 'none'`，并在完全离场后设置 `visibility = 'hidden'`，减少 GPU/事件开销。
    - Layer 2（Review）：`note-scroll-container` 作为 Cloze/Blur 的唯一滚动容器：
      - 复习模式：`x = 0, opacity = 1, scale = 1, zIndex = 10`。
      - 编辑模式：`x = '20%' , opacity = 0, scale ≈ 0.98, zIndex = 1`。
  - 这一模式保证了 Edit / Review 在布局上始终对齐，只以平移 +缩放表现模式切换，而不打断内部组件生命周期（减少重新挂载带来的抖动）。
- **头部模式切换胶囊（Write / Cloze / Blur）**：
  - 顶部统一 Header 中的模式按钮使用 `layoutId="activeModePill"` 的 `motion.div` 作为背景：
    - 点击切换 `viewMode` 时，该胶囊在不同按钮间滑动，视觉上连续；
    - 与 Library 中 Dashboard Segmented Control 使用同样的动画参数，保证全局一致的「滑块」手感。

### 7.3 Cloze ↔ Blur 过渡与 Blur Peek

- **模式过渡（Cloze / Blur）**：
  - 在 Review 层内部，使用 `AnimatePresence mode="wait"` 包裹一个 `motion.div`：
    - 以 `key={viewMode === 'master' ? 'master' : 'test'}` 区分 Cloze 与 Blur，使两种模式在同一占位上做交叉淡入淡出。
    - 入场：`initial { opacity: 0, filter: 'blur(4px)' }` → `animate { opacity: 1, filter: blur(0 | 5px) }`。
    - 离场：`exit { opacity: 0, filter: 'blur(4px)', transition: { duration: 0.1 } }`，过渡非常短促，避免打断记忆流。
- **Blur Peek（按住空格窥视原文）**：
  - 在 `viewMode === 'master'`（Blur 模式）下，NoteRenderer 监听全局 `keydown/keyup`：
    - 按下空格：`isPeeking = true`，通过动画将 `filter: blur(5px)` 变为 `blur(0px)`，短时间内还原原文。
    - 松开空格：`isPeeking = false`，恢复 `blur(5px)`，再次进入模糊状态。
  - 这一行为由 NoteRenderer 控制 Blur 外层容器的 CSS `filter`，而 BlurMode 内部只关心内容和布局，实现职责分离。

### 7.4 GradingBar 与 Immersive Controls

- **GradingBar 出入场**：
  - NoteRenderer 在中心列中使用一层 `AnimatePresence` 包裹 GradingBar 容器：
    - 初次出现：`initial { y: 100, opacity: 0 }` → `animate { y: 0, opacity: 1 }`。
    - 离场：`exit { y: 100, opacity: 0 }`，采用 `spring` 物理参数（`stiffness: 300, damping: 30`），给人「从底部弹出/收回」的 Dock 体验。
  - 容器本身使用固定定位 `fixed inset-x-0 bottom-0` + `pointer-events-none`；内部再包一层居中的 `max-w-3xl/5xl` 宽度胶囊，将 GradingBar 视觉上绑定到内容列，而不遮挡左右空白区域。
- **沉浸模式（Immersive Mode）与悬浮控制条**：
  - 当 `immersive === true` 时：
    - Header 使用 `motion.div` 将自身 `y` 平移和 `opacity` 降为 0，自动隐藏顶部 chrome，仅保留内容。
    - 内容列宽由 `max-w-3xl` 拉升到 `max-w-5xl`，GradingBar 宽度随之同步，形成更聚焦的阅读/复习区域。
  - `ImmersiveControls` 组件作为右上角浮动胶囊：
    - 使用 `motion.div` 的 `initial/animate/exit` 控制渐入/渐出。
    - 胶囊内展示「Focus Mode」标签和剩余卡片数 `remaining`，既是状态提示，也是退出入口（按钮触发 `onExit()`）。

> 统一原则：
> - 所有主要视图切换（Library ↔ Review、Edit ↔ Cloze/Blur、Cloze ↔ Blur）都采用 **低幅度位移 + 轻量缩放 + 短时淡入淡出**，避免生硬的「整屏闪切」。
> - 交互性控件（模式切换、评分按钮、浮动胶囊）统一使用 `spring` 物理参数与滑动胶囊（layoutId），提供连续、具弹性的触感。
> - 尽量通过持续挂载 + 显隐动画实现模式切换，减少组件卸载/重挂导致的状态丢失和性能抖动。
