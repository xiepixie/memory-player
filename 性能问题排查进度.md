# 性能问题排查进度

## 当前优先级总览（2025-11-24）

- **P0 / 最高优先级**：问题 5、问题 6、问题 7（EditMode 输入卡顿 / 日志 / 持久化）
- **P1**：问题 1、问题 2、问题 3、问题 4（启动链路 / 库视图 / Cloze 渲染）
- **P2**：问题 8（pointerout 事件链）

> 注：本表只反映当前阶段的排查与优化重点，随着实现推进可继续调整。

## 启动阶段（AuthGate / initDataService / Supabase）

- **问题 1：AuthGate 阻塞 Layout 首屏渲染**
  - `AuthGate` 中在 `status === 'ready'` 前会 `await initDataService('supabase')`。
  - `initDataService` 内又串行执行：`service.init()` → `auth.getUser()` → `loadVaults()` → `loadAllMetadata()` → `loadReviewHistory()`。
  - 结果：首屏必须等完 `/auth/v1/user` + `/rest/v1/vaults` + `/rest/v1/cards` + `/rest/v1/review_logs` 整条链，Perf 报告中 LCP 被拖到 5–6s。

- **优化方向**
  - AuthGate：不再同步 `await initDataService`，而是先 `setStatus('ready')` 渲染 `<Layout />`，再后台异步初始化数据服务。
  - `initDataService`：精简为只负责选择 Adapter、`service.init()` 与解析当前用户；移除其中的 `loadVaults` / `loadAllMetadata` / `loadReviewHistory`，避免把重 IO 放进启动关键路径。
  - 错误处理：数据加载失败只打日志 + Toast，不再阻塞 UI 渲染。

### （问题 1）当前状态（2025-11-24）
- `initDataService` 目前已精简为：选择 Adapter → `service.init()` →（若为 Supabase）解析当前用户，不再在其中主动调用 `loadVaults` / `loadAllMetadata` / `loadReviewHistory`，启动链路中的重 IO 明显减少。
- `AuthGate` 仍然在 `status === 'ready'` 之前同步 `await initDataService('supabase')`，但由于 `initDataService` 只做轻量工作，其对首屏 LCP 的影响已显著降低。
- 后续如果仍然观察到启动卡顿，可按原计划进一步改造为：先渲染 `<Layout />`，再在后台异步调用 `initDataService`，彻底解除 AuthGate 与数据加载的耦合。

---

## 库视图 / Dashboard（LibraryView / ReviewHistory / 动画）

- **问题 2：启动即全量加载 Vault 元数据 + 365 天 ReviewHistory**
  - `loadAllMetadata` → `SupabaseAdapter.getAllMetadata`：对 `cards` join `notes` 做全量或增量扫描，行数大时较重。
  - `loadReviewHistory`：一次性拉取最近 365 天 `review_logs`，本来只在统计视图需要，却被放进启动初始化链。
  - `LibraryView` 首屏已经包含：文件列表 + Dashboard（部分统计）+ FileTree + Welcome 背景动画，DOM / 布局压力较大。

- **优化方向**
  - Vault & Metadata：
    - 由 `LibraryView` 的 `useEffect` 按需调用 `loadVaults`；
    - 只有在选定 `currentVault` 且完成 `files` 扫描后，再触发 `loadAllMetadata`（并保持增量合并）。
  - ReviewHistory：
    - 从 `initDataService` 中移除；
    - 仅在进入 Dashboard / Insights Tab 且 `reviewHistory` 为空时再加载。
  - 动画：
    - 保留基础过渡，但为文件列表与背景大动画增加“低性能模式”或条件开关，必要时减少 stagger / 无限动画，降低长列表时的布局/重绘成本。

### （问题 2）当前状态（2025-11-24）
- Vault & Metadata：
  - `initDataService` 不再主动加载 vault / metadata；
  - `LibraryView` 在 `syncMode === 'supabase'` 且 `rootPath` 变化时按需调用 `loadVaults`；
  - 选定 `currentVault` 后由 `loadVaults` / `setCurrentVault` 触发 `loadAllMetadata`，并保持增量合并逻辑，避免在未选 vault 时就全表扫描。
- ReviewHistory：
  - 已从 `initDataService` 中移除；
  - 由 `Dashboard` 组件在挂载且 `reviewHistory` 为空时通过 `loadReviewHistory` 懒加载，只在进入统计视图时才触发。
- 动画：
  - Welcome / Library 视图仍保留既有过渡与背景动画；目前尚未引入“低性能模式”开关，后续可根据实际设备表现再评估是否需要削减 stagger / 无限动画。

---

## 学习 / 编辑阶段（NoteRenderer / ClozeMode / MarkdownContent）

- **问题 3：NoteRenderer 始终双层挂载 Edit + Review**
  - 结构：一个 `LayoutGroup` 中永久挂着两层：
    - Layer 1：`EditModeLazy`（编辑器 + Markdown 预览）。
    - Layer 2：`ClozeModeLazy` / `BlurModeLazy`（学习视图）。
  - 模式切换只通过 `motion.div` 的 `x / opacity / pointerEvents` 来“隐藏”，并没有卸载组件。
  - 在 100 张卡、长笔记时：Edit + Review 两套大 DOM 同时存在，Markdown 渲染、布局与动画的成本翻倍，导致滚动与交互明显卡顿。

### （问题 3）当前状态（2025-11-24）
- 结构仍采用 `LayoutGroup` + 双层 Layout（Edit 层 + Review 层），viewMode 通过 `motion.div` 控制可见性与指针事件。
- 为降低 Edit 侧的开销，`EditMode` 增加了 `active` 属性：在非 `edit` 模式时不再渲染 Markdown 预览部分，只保留 textarea 与相关逻辑，从而在学习模式下避免重复的大量 Markdown DOM。
- Cloze/Blur 层仍保持常驻挂载（以保证模式切换的流畅动画）；如果后续在极大队列/长文档下仍存在明显卡顿，可进一步朝“严格互斥渲染”（按 viewMode 卸载非当前层）的方向演进。

- **问题 4：ClozeMode / MarkdownContent 的动画与渲染开销**
  - `ClozeMode`：
    - 每个 cloze 是一个带 spring 动画的 `motion.span`（含 `whileHover` / `whileTap`）。
    - 每次 reveal 都可能触发 `canvas-confetti`（即便有颜色缓存，也会带来较大 CPU/GPU 开销）。
  - `MarkdownContent`：
    - 使用 `remarkMath` + `rehypeKatex` 渲染数学公式，对长文/大量公式是重 CPU；
    - 虽有 `memo` 包装，但在 Edit 预览中仍跟随 debounced 内容频繁更新。

- **优化方向**
  - 结构级：
    - 改为“互斥渲染”：`viewMode === 'edit'` 时只渲染 Edit 层；`viewMode === 'test'/'master'` 时只渲染 Review 层；
    - 如需保留视效，可用 `AnimatePresence` + keyed `motion.div` 做挂载/卸载过渡，而不是双层常驻。
  - 动画级：
    - Cloze：仅对“当前目标 cloze”使用 `motion.span`，上下文 cloze 使用普通 `<span>` + 轻量 CSS 过渡；
    - Confetti：为 reveal 增加节流（例如同一 note 内间隔 >= 2–3s，或只在评分成功后触发）。
  - Markdown / 解析频率：
    - `EditMode` 中将预览的去抖时间从 200ms 适当提高（例如 300–500ms），减小 `parseNote` + `MarkdownContent` 的调用频率；
    - 后续如仍存在瓶颈，再考虑对特别大的笔记做分块渲染或更细粒度的 memo。

### （问题 4）当前状态（2025-11-24）
- `ClozeMode`：
  - 仍使用 `motion.span`（带 `whileHover` / `whileTap`）渲染 cloze，高亮和过渡体验良好，但在极端大文档下理论上仍有一定动画成本；
  - Reveal 时会触发 `canvas-confetti`，已限制为只在“当前目标 cloze”或自由模式下激活，但尚未增加基于时间/频率的节流（例如全局 2–3s 间隔）。
- `MarkdownContent`：
  - 继续使用 `remarkMath` + `rehypeKatex` 处理数学；组件已通过 `React.memo` 包装，并在 Edit 预览中配合去抖后的内容使用；
  - 当前预览去抖时间仍为约 200ms，在一般长度的笔记上表现稳定，如遇特大文档可按计划提高到 300–500ms 或引入更细粒度的分块渲染。

- **问题 5：EditMode 输入卡顿的三层根因（Zustand / React / CSS）**
  - **Zustand 过度订阅（Over-subscription）**
    - 早期实现中，`EditMode` 使用 `const { ... } = useAppStore();` 直接订阅整个 store。
    - 这意味着：只要任意 store 字段变化（例如后台同步更新、会话统计变化、其它视图切换当前卡片），`EditMode` 都会被动 re-render。
    - 结果是产生大量“幽灵重渲染”：即使用户没有敲键盘，EditMode 也会因为全局状态变动而不断参与 React diff，放大渲染压力。

  - **React 渲染抖动（Render Thrashing）**
    - `EditMode` 在用户输入时本身需要高频重渲染以更新 `content`，这是不可避免的。
    - 但某些 UI（例如 “Unsaved changes” 状态指示器）实际上只依赖 `isDirty`，不需要在每一次按键时重新计算 DOM 与样式。
    - 之前状态指示器是内联在 `EditMode` JSX 中的一个带 `animate-pulse` 的 `<div>`，每次输入导致的 render 都会触发 React 对这块 DOM 的 reconcile。
    - 即便 className 文本没变，高频的虚拟 DOM 对比 + 实际样式更新，叠加主线程正在处理输入与解析，会造成肉眼可见的微顿。

  - **CSS 复合层 / Backdrop-Blur 重绘问题**
    - 状态指示器使用 `animate-pulse` 通过改变 `opacity` 实现闪烁效果，同时它位于一个带 `backdrop-blur` 的容器之内。
    - 在很多浏览器实现中，改变 blur 层内部元素的透明度会迫使浏览器重新计算并重绘整个模糊背景，属于 GPU 和合成层都较重的操作。
    - 当这种高频样式变化与 React 的重渲染周期重叠时，就会在 Performance Trace 中表现为长达数秒甚至十余秒的 `Recalculate style` / layout 任务（你截图里的 11s+ 即来自这里）。

- **（问题 5）优化方向（草案）**
  - Zustand 订阅：在 `EditMode` 中使用 selector + `useShallow` 精确选择所需字段，避免全局 store 更新触发不必要的 re-render.
  - 组件拆分：将 “Unsaved changes” 指示器抽成独立、只依赖 `isDirty` 的子组件（最好用 `memo` 包装），把与输入无关的 UI 从高频渲染路径中剥离.
  - 样式调整：尽量避免在带 `backdrop-blur` 的容器内部对 `opacity` 做高频动画；
    - 可以将脉冲动画移动到一个不参与 blur 计算的独立图层，或简化为静态样式 / 低频过渡.
    - 目标是让“输入 → 状态更新”的关键路径尽量只涉及轻量的 style 变化（如 transform），减少 GPU 与重绘压力.

### （问题 5）当前状态（2025-11-24）
- **Zustand 订阅**：`EditMode` 已改为通过 selector 只订阅 `currentNote` / `currentFilepath` / `loadNote` / `dataService` / `updateLastSync` / `currentVault` 等必要字段，不再直接依赖整棵 store，显著减少了全局状态变动带来的“幽灵重渲染”。
- **状态指示器样式**：Edit 工具栏中带 `backdrop-blur-md` 的容器内，已移除 `animate-pulse`，改为仅通过 `bg-warning` + `shadow` 的静态样式与轻量 `transition-colors` 表达“未保存”状态，避免 blur 层在每一帧做重绘。
- **光标相关计算**：`updateTargetClozeId` 现在包了一层 `requestAnimationFrame` 节流（`scheduleUpdateTargetClozeId`），textarea 的 `onClick` / `onSelect` / 光标方向键只触发节流后的更新，叠加已有的 150ms debounce，可以避免长文档下频繁正则扫描导致的输入抖动。
- **后续可选优化**：如仍有需要，可进一步将“Unsaved changes”指示器拆分为独立 memo 子组件，并视情况将预览去抖时间从 200ms 提高到 300–500ms 以降低 `parseNote` 与 `MarkdownContent` 频率。

---

## 其他性能元凶（日志 / 持久化 / 事件链）

- **问题 6：控制台日志爆炸（Run console task 4.5s+）**
  - **证据来源**：Performance 第四张截图（Run console task ≈ 4.58 秒）。
  - **现象**：短时间内打印了海量日志（可能在循环、频繁事件中 `console.log` 或直接打印巨大对象），DevTools 为渲染这些日志格式化输出，长时间占用主线程。
  - **影响**：浏览器在处理日志和 UI 更新之间来回切换，直接造成严重卡顿甚至“假死”。
  - **修复行动**：
    - 全局排查：删除 / 注释掉所有出现在渲染循环、`mousemove`、`pointerout`、滚动等高频事件中的 `console.log`；
    - 特别避免打印整个 store / 大数组等巨型对象，只在必要时打印精简信息或使用条件日志.

### （问题 6）当前状态（2025-11-24）
- 源码 `src/` 目录中，按 `console.log(` 全局搜索，目前仅剩一处被注释掉的调试语句（`useFileWatcher` 中的文件监控日志），渲染路径与高频事件处理函数中已无主动 `console.log` 调用。
- 仍保留少量 `console.error` / `console.warn` 用于错误与异常场景（如保存/同步失败），数量较少且不在高频循环内，对性能影响可忽略。
- 后续新增调试代码需继续遵守本节约束：避免在循环、pointer/mouse/scroll 等高频事件中直接打印日志，必要时通过条件判断或采样降低频率。

- **问题 7：Zustand persist 同步写入（localStorage 阻塞）**
  - **证据来源**：第三张截图右下角调用栈中出现 `zustand_middleware.js` 与 `setItem`.
  - **现象**：使用了 Zustand 的 `persist` 中间件，将整个状态树同步写入 `localStorage`；当 state 较大且更新频繁时，每次 `setState` 都会触发一次同步 `localStorage.setItem`.
  - **分析**：
    - `localStorage.setItem` 是同步 API，会阻塞主线程直到写入完成；
    - 如果状态中包含大对象（如完整文件列表、元数据 Map 等），序列化 + 写盘的开销会非常可观；
    - 一旦与高频事件（如 pointer 事件）耦合，就会形成“频繁写盘 → UI 卡顿”的恶性循环.
  - **修复行动**：
    - 临时验证：在开发环境中关闭或注释掉 `persist` 中间件配置，确认卡顿是否明显缓解；
    - 长期方案：
      - 使用 `partialize` 只持久化必要的轻量字段，排除大体量数据结构；
      - 如需长期存大量数据，考虑迁移到异步存储（IndexedDB 等），避免同步 `setItem` 阻塞主线程.

### （问题 7）当前状态（2025-11-24）
- `appStore` 已使用 `persist` 的 `partialize` 选项，仅将下列字段写入 `localStorage`：`rootPath`、`recentVaults`、`files`、`theme`、`fileMetadatas`、`lastServerSyncAt`，不再持久化整个状态树，较原始方案已显著减轻同步写盘压力。
- 其中 `fileMetadatas` 可能仍然较大，但更新频率相对较低，配合增量同步策略，理论上不会再与高频 pointer 事件强耦合；如后续在超大库下仍观察到 `setItem` 卡顿，可进一步考虑只持久化必要元数据字段或迁移到 IndexedDB。
- 短期内可通过在 DevTools Performance 中观察 `LocalStorage.setItem` 是否仍出现在热点调用栈中，来验证当前 partialize 策略是否足够；如无明显热点，则可将问题 7 的优先级从 P0 降为 P1，仅在后期做架构性优化时一并处理。

- **问题 8：pointerout 鼠标移出事件触发整条灾难链**
  - **证据来源**：第二、三张截图中顶层事件为 `Event: pointerout`，其下挂接了状态更新与样式重计算.
  - **场景还原**：
    - 鼠标移出某个组件元素（`pointerout` 触发）；
    - 事件处理函数中更新了 Zustand store（例如切换 hover 状态、选中状态等）；
    - `persist` 中间件尝试将整个 state 同步写入 `localStorage`（问题 7）；
    - 状态变化驱动 React 组件更新，其中可能包含大量 DOM 卸载 / 样式变化，以及高频 `console.log`（问题 6）；
    - 最终在 Performance 中体现为长时间的 `Recalculate style` / layout 任务，尤其当被卸载/隐藏的是一个包含大量节点的区域时.
  - **修复行动**：
    - 定位具体绑定 `pointerout` 的组件与 handler，审查是否在此事件中做了：
      - 重型状态更新（大对象写入 store）；
      - 触发持久化写入；
      - 再叠加调试日志输出；
    - 尽量将 pointer 类事件中的逻辑降级为**轻量、本地 UI 状态**，避免在鼠标移动/移出时写入全局 store 或触发持久化.

### （问题 8）当前状态（2025-11-24）
- 当前代码中未再发现显式绑定 `pointerout` 的事件处理函数，说明此前重构/清理已在一定程度上“自然拆掉”这条灾难链路。
- 仍需在后续功能开发中遵守本节约束：
  - pointer / mouse / scroll 等高频事件中尽量使用组件本地 state 表达 UI 反馈；
  - 避免在这些事件内直接写入大型全局 store 或触发持久化；
  - 如未来在 Performance Trace 中再次观察到以 pointerout 为入口的大型任务，再按本节“修复行动”逐一排查。

- **手术步骤总结（针对本组问题）**
  - 第一步：全局搜索并移除高频路径中的 `console.log`（循环、pointer/mouse 事件、渲染函数内部）。
  - 第二步：暂时关闭 Zustand `persist`，验证卡顿是否消失；随后通过 `partialize` 精简持久化字段或迁移到异步存储.
  - 第三步：定位 `pointerout` 相关组件，检查并削减其中对全局 store 的写入与样式突变，必要时改为本地 state + 低频更新.
