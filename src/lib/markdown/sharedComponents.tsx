/**
 * Shared Markdown Components Factory
 * 
 * Centralizes component mappings for ReactMarkdown to avoid code duplication
 * between SimpleBlockRenderer and BlockRenderer.
 * 
 * Handles:
 * - Table styling (responsive with horizontal scroll)
 * - Cloze/ErrorLink rendering with click handlers
 * - Code block styling
 * - Typography (headings, paragraphs)
 */

import React, { type MutableRefObject } from 'react';
import clsx from 'clsx';
import { MathClozeBlock } from '../../components/shared/MathClozeBlock';
import { MathBlock } from '../../components/shared/MathBlock';
import { MathInline } from '../../components/shared/MathInline';
import { MarkdownImage } from '../../components/shared/MarkdownImage';
import { ClozeWithContext } from '../../components/shared/ClozeWithContext';

// Types
export type ClozeVariant = 'edit' | 'review' | 'blur';

export interface ClozeHandlerCallbacks {
  onClozeClick?: (id: number, occurrenceIndex: number, target: HTMLElement) => void;
  onClozeContextMenu?: (id: number, occurrenceIndex: number, target: HTMLElement, event: React.MouseEvent) => void;
  onErrorLinkClick?: (kind: 'unclosed' | 'malformed' | 'dangling', occurrenceIndex: number, target?: HTMLElement) => void;
}

// Cloze regex patterns
const CLOZE_PATTERN = /\{\{c(\d+)::([^}]*?)(?:::([^}]*))?\}\}/g;
const UNCLOSED_CLOZE = /\{\{c\d+::[^}]*$/;
const MALFORMED_CLOZE = /\{\{c[^0-9]/;

/**
 * Build ReactMarkdown components prop
 */
export function buildMarkdownComponents(
  variant: ClozeVariant,
  clozeCounts: MutableRefObject<Record<number, number>>,
  callbacks: ClozeHandlerCallbacks
): Record<string, React.ComponentType<any>> {
  const { onClozeClick, onClozeContextMenu, onErrorLinkClick } = callbacks;
  
  // Track error link occurrences
  const errorCounts: Record<string, number> = {};
  
  return {
    // Table components
    table: ({ children }: { children: React.ReactNode }) => (
      <div className="overflow-x-auto my-4 rounded-lg border border-base-content/10">
        <table className="table table-zebra w-full">{children}</table>
      </div>
    ),
    thead: ({ children }: { children: React.ReactNode }) => (
      <thead className="bg-base-200">{children}</thead>
    ),
    th: ({ children }: { children: React.ReactNode }) => (
      <th className="text-base-content/80 font-semibold">{children}</th>
    ),
    td: ({ children }: { children: React.ReactNode }) => (
      <td className="text-base-content/90">{children}</td>
    ),
    
    // Image component
    img: (props: React.ImgHTMLAttributes<HTMLImageElement>) => (
      <MarkdownImage {...props} />
    ),
    
    // Code blocks - with special handling for math-cloze
    pre: ({ children }: { children: React.ReactNode }) => {
      // Check if this is a math-cloze block - if so, don't wrap in pre
      // The code component will handle rendering the MathClozeBlock directly
      const childElement = React.Children.toArray(children)[0] as React.ReactElement<{ className?: string }> | undefined;
      const childClassName = childElement?.props?.className || '';
      if (typeof childClassName === 'string' && childClassName.includes('language-math-cloze-')) {
        // Just render the code component's output directly (no pre wrapper)
        return <>{children}</>;
      }
      // Regular code blocks: use mockup-code styling
      return (
        <div className="mockup-code bg-neutral text-neutral-content my-4 text-sm">
          <pre className="px-4">{children}</pre>
        </div>
      );
    },
    code: ({ className, children, ...props }: { className?: string; children: React.ReactNode }) => {
      const match = /language-([\w-]+)/.exec(className || '');
      const lang = match?.[1];
      const isInline = !match;

      // Special handling for math cloze blocks generated by parser.ts
      if (lang && lang.startsWith('math-cloze-')) {
        const idStr = lang.replace('math-cloze-', '');
        const id = parseInt(idStr, 10);
        const latex = String(children).trim();

        // Track occurrence index for this math cloze
        const numId = Number.isNaN(id) ? 0 : id;
        let occurrenceIndex = 0;
        if (!Number.isNaN(id)) {
          occurrenceIndex = clozeCounts.current[numId] || 0;
          clozeCounts.current[numId] = occurrenceIndex + 1;
        }
        const clozeKey = `${numId}-${occurrenceIndex}`;

        // === BLUR MODE: Just render plain math without cloze styling/badge ===
        if (variant === 'blur') {
          // Use MathBlock directly for clean display without cloze decoration
          return <MathBlock latex={latex} />;  
        }

        // === REVIEW MODE: Use Context for state ===
        if (variant === 'review') {
          return (
            <ClozeWithContext
              type="math"
              id={numId}
              clozeKey={clozeKey}
              latex={latex}
            />
          );
        }

        // === EDIT MODE (default): Always revealed, click to locate ===
        const hasInteraction = !!onClozeClick;
        
        return (
          <div
            id={`cloze-item-${id}`}
            className="my-4"
            onClick={(e) => {
              if (onClozeClick && !Number.isNaN(id)) {
                e.preventDefault();
                e.stopPropagation();
                onClozeClick(id, occurrenceIndex, e.currentTarget);
              }
            }}
            onContextMenu={(e) => {
              if (onClozeContextMenu && !Number.isNaN(id)) {
                e.preventDefault();
                e.stopPropagation();
                onClozeContextMenu(id, occurrenceIndex, e.currentTarget, e);
              }
            }}
          >
            <MathClozeBlock
              id={numId}
              latex={latex}
              isRevealed={true}
              isInteractive={hasInteraction}
              variant="edit"
              onToggle={hasInteraction ? () => onClozeClick?.(id, occurrenceIndex, document.getElementById(`cloze-item-${id}`) as HTMLElement) : undefined}
            />
          </div>
        );
      }

      // Regular code blocks
      // Note: For block code, the pre component handles the outer wrapper (mockup-code styling)
      // So we just return the <code> element here
      return isInline ? (
        <code className="bg-base-300 px-1.5 py-0.5 rounded text-sm font-mono text-primary font-bold" {...props}>
          {children}
        </code>
      ) : (
        <code className={className} {...props}>{children}</code>
      );
    },
    
    // Paragraph with cloze detection
    p: ({ children, node }: { children: React.ReactNode; node?: any }) => {
      // Check if this is a math block
      if (node?.children?.[0]?.type === 'text') {
        const text = node.children[0].value;
        if (text.startsWith('$$') && text.endsWith('$$')) {
          return <>{children}</>;
        }
      }
      
      // Process children for cloze patterns
      const processedChildren = React.Children.map(children, (child) => {
        if (typeof child !== 'string') return child;
        
        // Check for error patterns first
        if (UNCLOSED_CLOZE.test(child)) {
          const kind = 'unclosed';
          const idx = errorCounts[kind] || 0;
          errorCounts[kind] = idx + 1;
          
          return (
            <span
              className="bg-error/20 text-error px-1 rounded cursor-pointer"
              onClick={(e) => onErrorLinkClick?.(kind, idx, e.currentTarget)}
            >
              {child}
            </span>
          );
        }
        
        if (MALFORMED_CLOZE.test(child)) {
          const kind = 'malformed';
          const idx = errorCounts[kind] || 0;
          errorCounts[kind] = idx + 1;
          
          return (
            <span
              className="bg-warning/20 text-warning px-1 rounded cursor-pointer"
              onClick={(e) => onErrorLinkClick?.(kind, idx, e.currentTarget)}
            >
              {child}
            </span>
          );
        }
        
        // Process cloze patterns
        const parts: React.ReactNode[] = [];
        let lastIndex = 0;
        let match;
        
        const regex = new RegExp(CLOZE_PATTERN.source, 'g');
        while ((match = regex.exec(child)) !== null) {
          // Add text before match
          if (match.index > lastIndex) {
            parts.push(child.slice(lastIndex, match.index));
          }
          
          const id = parseInt(match[1], 10);
          const content = match[2];
          const hint = match[3];
          
          // Track occurrence
          const occurrence = clozeCounts.current[id] || 0;
          clozeCounts.current[id] = occurrence + 1;
          
          // Check if content is math
          const isMath = content.startsWith('$') && content.endsWith('$');
          
          if (isMath) {
            // Map variant to MathClozeBlock props
            const isEditMode = variant === 'edit';
            const isBlurMode = variant === 'blur';
            
            parts.push(
              <MathClozeBlock
                key={`cloze-${id}-${occurrence}`}
                id={id}
                clozeKey={`${id}-${occurrence}`}
                latex={content.slice(1, -1)}
                isRevealed={isEditMode || isBlurMode}
                isInteractive={!isEditMode}
                variant={isEditMode ? 'edit' : 'review'}
              />
            );
          } else {
            // Regular cloze
            const baseClass = 'inline-flex items-center gap-1 px-2 py-0.5 rounded font-medium transition-colors';
            const variantClass = variant === 'edit' 
              ? 'bg-primary/20 text-primary hover:bg-primary/30 cursor-pointer'
              : variant === 'review'
              ? 'bg-secondary/20 text-secondary'
              : 'bg-base-300 text-base-content/50';
            
            parts.push(
              <span
                key={`cloze-${id}-${occurrence}`}
                className={clsx(baseClass, variantClass)}
                data-cloze-id={id}
                data-occurrence={occurrence}
                onClick={(e) => onClozeClick?.(id, occurrence, e.currentTarget)}
                onContextMenu={(e) => {
                  e.preventDefault();
                  onClozeContextMenu?.(id, occurrence, e.currentTarget, e);
                }}
              >
                <span className="text-xs opacity-60">c{id}</span>
                <span>{content}</span>
                {hint && <span className="text-xs opacity-50">({hint})</span>}
              </span>
            );
          }
          
          lastIndex = match.index + match[0].length;
        }
        
        // Add remaining text
        if (lastIndex < child.length) {
          parts.push(child.slice(lastIndex));
        }
        
        return parts.length > 0 ? parts : child;
      });
      
      return <p className="my-4 leading-relaxed">{processedChildren}</p>;
    },
    
    // Lists
    ul: ({ children }: { children: React.ReactNode }) => (
      <ul className="list-disc list-inside my-4 space-y-1">{children}</ul>
    ),
    ol: ({ children }: { children: React.ReactNode }) => (
      <ol className="list-decimal list-inside my-4 space-y-1">{children}</ol>
    ),
    li: ({ children }: { children: React.ReactNode }) => (
      <li className="text-base-content/90">{children}</li>
    ),
    
    // Blockquote
    blockquote: ({ children }: { children: React.ReactNode }) => (
      <blockquote className="border-l-4 border-primary/50 pl-4 my-4 italic text-base-content/80">
        {children}
      </blockquote>
    ),
    
    // Typography
    strong: ({ children }: { children: React.ReactNode }) => (
      <strong className="font-bold text-primary/90">{children}</strong>
    ),
    
    // Headings
    h1: ({ children }: { children: React.ReactNode }) => (
      <h1 className="font-serif text-3xl font-bold mt-8 mb-4 text-base-content scroll-mt-20">{children}</h1>
    ),
    h2: ({ children }: { children: React.ReactNode }) => (
      <h2 className="font-serif text-2xl font-bold mt-6 mb-3 text-base-content/90 border-b border-base-content/10 pb-2 scroll-mt-20">{children}</h2>
    ),
    h3: ({ children }: { children: React.ReactNode }) => (
      <h3 className="font-serif text-xl font-bold mt-5 mb-2 text-base-content/80 scroll-mt-20">{children}</h3>
    ),
    h4: ({ children }: { children: React.ReactNode }) => (
      <h4 className="font-bold mt-4 mb-2 text-base-content/80 scroll-mt-20">{children}</h4>
    ),
    h5: ({ children }: { children: React.ReactNode }) => (
      <h5 className="font-bold mt-3 mb-2 text-base-content/70 scroll-mt-20">{children}</h5>
    ),
    h6: ({ children }: { children: React.ReactNode }) => (
      <h6 className="font-bold mt-3 mb-2 text-base-content/60 scroll-mt-20">{children}</h6>
    ),
    
    // Horizontal rule
    hr: () => <hr className="my-8 border-base-content/10" />,
    
    // Links - with special handling for cloze links
    a: ({ href, children }: { href?: string; children: React.ReactNode }) => {
      // Error anchors for broken clozes
      if (href?.startsWith('#error-unclosed') || href?.startsWith('#error-malformed') || href?.startsWith('#error-dangling')) {
        const isUnclosed = href.startsWith('#error-unclosed');
        const isMalformed = href.startsWith('#error-malformed');
        const kind: 'unclosed' | 'malformed' | 'dangling' = isUnclosed
          ? 'unclosed'
          : isMalformed
            ? 'malformed'
            : 'dangling';

        const parts = href.split('-');
        const occurrenceIndex = parts.length >= 3 ? Number.parseInt(parts[2], 10) || 0 : 0;

        const handleClick = (e: React.MouseEvent<HTMLSpanElement>) => {
          if (!onErrorLinkClick) return;
          e.preventDefault();
          e.stopPropagation();
          onErrorLinkClick(kind, occurrenceIndex, e.currentTarget);
        };

        if (kind === 'unclosed') {
          return (
            <span
              className="inline-flex align-middle items-center gap-1 px-1.5 py-0 rounded bg-error/10 text-error border border-error/20 font-mono text-sm cursor-pointer h-[1.5em]"
              title="Unclosed Cloze (missing '}}')"
              onClick={onErrorLinkClick ? handleClick : undefined}
            >
              {children}
              <span className="opacity-50">...{'}}'}?</span>
            </span>
          );
        }

        if (kind === 'malformed') {
          return (
            <span
              className="inline-flex align-middle items-center gap-1 px-1.5 py-0 rounded bg-warning/10 text-warning-content border border-warning/20 font-mono text-sm cursor-pointer h-[1.5em]"
              title="Malformed Cloze (syntax error)"
              onClick={onErrorLinkClick ? handleClick : undefined}
            >
              {children}
            </span>
          );
        }

        // Dangling
        return (
          <span
            className="inline-flex align-middle items-center gap-1 px-1.5 py-0 rounded bg-error/10 text-error border border-error/20 font-mono text-sm cursor-pointer h-[1.5em]"
            title="Dangling cloze closer (extra '}}' without opening)"
            onClick={onErrorLinkClick ? handleClick : undefined}
          >
            {children}
          </span>
        );
      }

      // Cloze links
      if (href?.startsWith('#cloze-')) {
        const parts = href.replace('#cloze-', '').split('-');
        const id = parts[0];
        const hint = parts.length > 1 ? decodeURIComponent(parts.slice(1).join('-')) : undefined;
        
        const numId = parseInt(id, 10);
        let occurrenceIndex = 0;
        if (!Number.isNaN(numId)) {
          occurrenceIndex = clozeCounts.current[numId] || 0;
          clozeCounts.current[numId] = occurrenceIndex + 1;
        }
        const clozeKey = `${numId}-${occurrenceIndex}`;

        // === BLUR MODE: Just render plain text ===
        if (variant === 'blur') {
          return <span>{children}</span>;
        }

        // === REVIEW MODE: Use Context for state ===
        if (variant === 'review') {
          return (
            <ClozeWithContext
              key={clozeKey}
              type="inline"
              id={numId}
              clozeKey={clozeKey}
              hint={hint}
            >
              {children}
            </ClozeWithContext>
          );
        }

        // === EDIT MODE (default): Always revealed, click to locate ===
        return (
          <span 
            id={`cloze-item-${id}`}
            data-cloze-id={id}
            className={clsx(
              "inline group",
              onClozeClick && "cursor-pointer"
            )}
            title={hint ? `Hint: ${hint}` : `Cloze #${id}`}
            onClick={(e) => {
              if (onClozeClick && !Number.isNaN(numId)) {
                e.preventDefault();
                e.stopPropagation();
                onClozeClick(numId, occurrenceIndex, e.currentTarget);
              }
            }}
            onContextMenu={(e) => {
              if (onClozeContextMenu && !Number.isNaN(numId)) {
                e.preventDefault();
                e.stopPropagation();
                onClozeContextMenu(numId, occurrenceIndex, e.currentTarget, e);
              }
            }}
          >
            {/* ID Badge */}
            <sup className={clsx(
              "text-[9px] font-mono font-bold select-none px-0.5 rounded",
              "transition-colors duration-150",
              "text-primary bg-primary/10",
              onClozeClick && "group-hover:bg-primary/20"
            )}>
              {id}
            </sup>
            {/* Content */}
            <span className={clsx(
              "border-b-2 border-primary/40 text-base-content rounded-sm px-0.5",
              "transition-colors duration-150",
              onClozeClick && "hover:bg-primary/10 hover:border-primary active:bg-primary/15"
            )}>
              {children}
            </span>
            {hint && (
              <span className="sr-only">Hint: {hint}</span>
            )}
          </span>
        );
      }
      
      // Highlight format used by ==text== in parser
      if (href === '#highlight') {
        return (
          <span className="border-b-2 border-primary/60 pb-0.5 text-primary">
            {children}
          </span>
        );
      }

      // Regular external links
      return (
        <a
          href={href}
          className="link link-primary"
          target={href?.startsWith('http') ? '_blank' : undefined}
          rel={href?.startsWith('http') ? 'noopener noreferrer' : undefined}
        >
          {children}
        </a>
      );
    },
    
    // Async math components (rendered via Web Worker)
    'math-block': ({ latex }: { latex: string }) => <MathBlock latex={latex} />,
    'math-inline': ({ latex }: { latex: string }) => <MathInline latex={latex} />,
  };
}
